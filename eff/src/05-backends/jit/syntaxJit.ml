open Language
open Format

(* module Id = Symbol.Make (Symbol.String)
   type id = Id.t *)

module Id = struct
  type t =
    | SrcId of Term.Variable.t (* coming from source symbols *)
    | Name of string (* generated by us, with a fixed name *)
    | Gensym of string * int (* generated by us, with a prefix and a number *)

  let _next_id = ref 0

  let fresh prefix =
    incr _next_id;
    Gensym (prefix, !_next_id)

  let print fmt = function
    | SrcId v -> (
        match (Obj.magic v : int * Term.Variable.annot) with
        | id, _annot ->
            Format.fprintf fmt "%a_%d"
              (fun x y -> Term.Variable.print ~safe:false y x)
              v id)
    | Name name -> fprintf fmt "%s" name
    | Gensym (prefix, n) -> fprintf fmt "%s_%d" prefix n
end

type id = Id.t
type purity = Pure | Effectful

type typ =
  | Top
  | Ptr
  | Num
  | Bottom
  | Base of base_type
  | Function of typ list * typ * purity
  | Codata of id * method_type list
  | Data of id * constructor_type list
  | Stack of typ * typ list
  | Ref of typ

and base_type =
  | Int
  | Bool
  | Double
  | String
  | Label of typ option * typ option
  | Unit

and method_type = { method_tag : id; params : typ list; return : typ }
and constructor_type = { cns_tag : id; fields : typ list }

type var = { id : id; typ : typ }

type term =
  | Var of var
  | Abs of var list * term
  | App of term * term list
  | Seq of term list
  | Let of definition list * term
  | LetRec of definition list * term
  | IfZero of term * term * term
  | Construct of id * id * term list
  | Project of term * id * id * int
  | Match of term * id * (id * clause) list * clause
  | Switch of term * (literal * term) list * term
  | New of id * (id * clause) list
  | Invoke of term * id * id * term list
  | LetRef of var * term * term * term
  | Load of term
  | Store of term * term
  | FreshLabel
  | Reset of term * var * term option * term * clause
  | Shift of term * term * var * term * typ
  | Resume of term * term list
  | Resumed of term * term
  | GetDynamic of term * term
  | Literal of literal
  | Primitive of string * term list * var list * term
  | DebugWrap of string * term

and definition = { name : var; value : term; export_as : string list }
and clause = { params : var list; body : term }

and literal =
  | LitInt of int
  | LitBool of bool
  | LitDouble of float
  | LitString of string
  | LitStringWithFormat of string * string
  | LitLabel
  | LitUnit

type program = { definitions : definition list; main : term }

let escape_str str =
  String.of_seq
    (Seq.flat_map
       (function
         | '\\' -> String.to_seq "\\\\"
         | '"' -> String.to_seq "\\\""
         | '\n' -> String.to_seq "\\n"
         | '\t' -> String.to_seq "\\t"
         | c when Char.code c < 32 (* || Char.code c > 126 *) ->
             (* TODO correctly handle unicode*)
             String.to_seq (Printf.sprintf "\\u%04x" (Char.code c))
         | c -> Seq.return c)
       (String.to_seq str))

let print_str fmt s = fprintf fmt {|"%s"|} (escape_str s)

let print_id fmt = function
  | s -> fprintf fmt {|%a|} print_str (Format.asprintf {|%a|} Id.print s)

let print_purity fmt = function
  | Pure -> fprintf fmt {|"Pure"|}
  | Effectful -> fprintf fmt {|"Effectful"|}

let rec print_typ fmt = function
  | Top -> fprintf fmt {|{"op": "Top"}|}
  | Ptr -> fprintf fmt {|{"op": "Ptr"}|}
  | Num -> fprintf fmt {|{"op": "Num"}|}
  | Bottom -> fprintf fmt {|{"op": "Bottom"}|}
  | Base b -> print_base_type fmt b
  | Function (params, ret, purity) ->
      fprintf fmt
        {|{"op": "Function", "params": [%a], "return": %a, "purity": %a}|}
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_typ)
        params print_typ ret print_purity purity
  | Codata (tag, methods) ->
      fprintf fmt {|{"op": "Codata", "interface_tag": %a, "methods": [%a]}|}
        print_id tag
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           print_method_type)
        methods
  | Data (tag, constructors) ->
      fprintf fmt {|{"op": "Data", "type_tag": %a, "constructors": [%a]}|}
        print_id tag
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           print_constructor_type)
        constructors
  | Stack (ret, args) ->
      fprintf fmt {|{"op": "Stack", "resume_return": %a, "resume_args": [%a]}|}
        print_typ ret
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_typ)
        args
  | Ref t -> fprintf fmt {|{"op": "Ref", "to": %a}|} print_typ t

and print_base_type fmt = function
  | Int -> fprintf fmt {|{"op": "Int"}|}
  | Bool -> fprintf fmt {|{"op": "Bool"}|}
  | Double -> fprintf fmt {|{"op": "Double"}|}
  | String -> fprintf fmt {|{"op": "String"}|}
  | Label (Some at, Some bnd) ->
      fprintf fmt {|{"op": "Label", "at": %a, "binding": %a}|} print_typ at
        print_typ bnd
  | Label (None, Some bnd) ->
      fprintf fmt {|{"op": "Label", "binding": %a}|} print_typ bnd
  | Label (Some at, None) ->
      fprintf fmt {|{"op": "Label", "at": %a}|} print_typ at
  | Label (None, None) -> fprintf fmt {|"Label"|}
  | Unit -> fprintf fmt {|{"op": "Unit"}|}

and print_method_type fmt { method_tag; params; return } =
  fprintf fmt {|{"tag": %a, "params": [%a], "return": %a}|} print_id method_tag
    (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_typ)
    params print_typ return

and print_constructor_type fmt { cns_tag; fields } =
  fprintf fmt {|{"tag": %a, "fields": [%a]}|} print_id cns_tag
    (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_typ)
    fields

and print_var fmt { id; typ } =
  fprintf fmt {|{"id": %a, "type": %a}|} print_id id print_typ typ

let print_literal fmt = function
  | LitInt i ->
      fprintf fmt {|{"op": "Literal", "type": {"op": "Int"}, "value": %d}|} i
  | LitBool b ->
      fprintf fmt {|{"op": "Literal", "type": {"op": "Bool"}, "value": %s}|}
        (if b then "true" else "false")
  | LitDouble d ->
      fprintf fmt {|{"op": "Literal", "type": {"op": "Double"}, "value": %f}|} d
  | LitString s ->
      fprintf fmt {|{"op": "Literal", "type": {"op": "String"}, "value": %a}|}
        print_str s
  | LitStringWithFormat (s, sfmt) ->
      fprintf fmt
        {|{"op": "Literal", "type": {"op": "String"}, "value": %a, "format": %a}|}
        print_str s print_str sfmt
  | LitLabel -> fprintf fmt {|{"op": "Literal", "type": {"op": "Label"}}|}
  | LitUnit -> fprintf fmt {|{"op": "Literal", "type": {"op": "Unit"}}|}

and print_pair printer1 printer2 fmt (x, y) =
  fprintf fmt {|{"tag": %a, "value": %a}|} printer1 x printer2 y

and print_switch_case printer1 printer2 fmt (x, y) =
  fprintf fmt {|{"value": %a, "then": %a}|} printer1 x printer2 y

let rec print_term fmt = function
  | Var { id; typ } ->
      fprintf fmt {|{"op": "Var", "id": %a, "type": %a}|} print_id id print_typ
        typ
  | Abs (params, body) ->
      fprintf fmt {|{"op": "Abs", "params": [%a], "body": %a}|}
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_var)
        params print_term body
  | App (fn, args) ->
      fprintf fmt {|{"op": "App", "fn": %a, "args": [%a]}|} print_term fn
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_term)
        args
  | Seq terms ->
      fprintf fmt {|{"op": "Seq", "elems": [%a]}|}
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_term)
        terms
  | Let (defs, body) ->
      fprintf fmt {|{"op": "Let", "definitions": [%a], "body": %a}|}
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           print_definition)
        defs print_term body
  | LetRec (defs, body) ->
      fprintf fmt {|{"op": "LetRec", "definitions": [%a], "body": %a}|}
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           print_definition)
        defs print_term body
  | IfZero (cond, then_, else_) ->
      fprintf fmt {|{"op": "IfZero", "cond": %a, "then": %a, "else": %a}|}
        print_term cond print_term then_ print_term else_
  | Construct (type_tag, tag, args) ->
      fprintf fmt
        {|{"op": "Construct", "type_tag": %a, "tag": %a, "args": [%a]}|}
        print_id type_tag print_id tag
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_term)
        args
  | Project (scrutinee, type_tag, tag, field) ->
      fprintf fmt
        {|{"op": "Project", "scrutinee": %a, "type_tag": %a, "tag": %a, "field": %d}|}
        print_term scrutinee print_id type_tag print_id tag field
  | Match (scrutinee, type_tag, clauses, default_clause) ->
      fprintf fmt
        {|{"op": "Match", "scrutinee": %a, "type_tag": %a, "clauses": [%a], "default_clause": %a}|}
        print_term scrutinee print_id type_tag
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           print_tagged_clause)
        clauses print_clause default_clause
  | Switch (scrutinee, cases, default) ->
      fprintf fmt
        {|{"op": "Switch", "scrutinee": %a, "cases": [%a], "default": %a}|}
        print_term scrutinee
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           (print_switch_case print_literal print_term))
        cases print_term default
  | New (ifce_tag, methods) ->
      fprintf fmt {|{"op": "New", "ifce_tag": %a, "methods": [%a]}|} print_id
        ifce_tag
        (pp_print_list
           ~pp_sep:(fun fmt () -> fprintf fmt ", ")
           print_tagged_clause)
        methods
  | Invoke (receiver, ifce_tag, tag, args) ->
      fprintf fmt
        {|{"op": "Invoke", "receiver": %a, "ifce_tag": %a, "tag": %a, "args": [%a]}|}
        print_term receiver print_id ifce_tag print_id tag
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_term)
        args
  | LetRef (ref_, region, binding, body) ->
      fprintf fmt
        {|{"op": "LetRef", "ref": %a, "region": %a, "binding": %a, "body": %a}|}
        print_var ref_ print_term region print_term binding print_term body
  | Load ref_ -> fprintf fmt {|{"op": "Load", "ref": %a}|} print_term ref_
  | Store (ref_, value) ->
      fprintf fmt {|{"op": "Store", "ref": %a, "value": %a}|} print_term ref_
        print_term value
  | FreshLabel -> fprintf fmt {|{"op": "FreshLabel"}|}
  | Reset (label, region, None, body, return) ->
      fprintf fmt
        {|{"op": "Reset", "label": %a, "region": %a, "body": %a, "return": %a}|}
        print_term label print_var region print_term body print_clause return
  | Reset (label, region, Some binding, body, return) ->
      fprintf fmt
        {|{"op": "Reset", "label": %a, "region": %a, "binding": %a, "body": %a, "return": %a}|}
        print_term label print_var region print_term binding print_term body
        print_clause return
  | Shift (label, n, k, body, return_type) ->
      fprintf fmt
        {|{"op": "Shift", "label": %a, "n": %a, "k": %a, "body": %a, "returnType": %a}|}
        print_term label print_term n print_var k print_term body print_typ
        return_type
  | Resume (k, args) ->
      fprintf fmt {|{"op": "Resume", "k": %a, "args": [%a]}|} print_term k
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_term)
        args
  | Resumed (k, body) ->
      fprintf fmt {|{"op": "Resumed", "k": %a, "body": %a}|} print_term k
        print_term body
  | Literal lit -> print_literal fmt lit
  | Primitive (name, args, returns, rest) ->
      fprintf fmt
        {|{"op": "Primitive", "name": %a, "args": [%a], "returns": [%a], "rest": %a}|}
        print_str name
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_term)
        args
        (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_var)
        returns print_term rest
  | DebugWrap (msg, body) ->
      fprintf fmt {|{"op": "DebugWrap", "annotation": %a, "inner": %a}|}
        print_str msg print_term body
  | GetDynamic (lbl, n) ->
      fprintf fmt {|{"op": "GetDynamic", "label": %a, "n": %a}|} print_term lbl
        print_term n

and print_definition fmt { name; value; export_as } =
  fprintf fmt {|{"name": %a, "value": %a, "export_as": [%a]}|} print_var name
    print_term value
    (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_str)
    export_as

and print_clause fmt { params; body } =
  fprintf fmt {|{"params": [%a], "body": %a}|}
    (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_var)
    params print_term body

and print_tagged_clause fmt (tag, { params; body }) =
  fprintf fmt {|{"tag": %a, "params": [%a], "body": %a}|} print_id tag
    (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_var)
    params print_term body

let print_program fmt { definitions; main } =
  fprintf fmt {|{"definitions": [%a], "main": %a}|}
    (pp_print_list ~pp_sep:(fun fmt () -> fprintf fmt ", ") print_definition)
    definitions print_term main
