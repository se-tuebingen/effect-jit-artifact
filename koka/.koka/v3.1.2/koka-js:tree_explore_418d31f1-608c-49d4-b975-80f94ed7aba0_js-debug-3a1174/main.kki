module interface main
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/os/env = std/os/env = "";
import std/text/parse = std/text/parse = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// ctl choose
// ```
recursive effect type choose[6,1,6,13] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-choose[6,1,6,13](@cfc: std/core/types/int, @ctl-choose: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) -> (choose :: (E, V) -> V)<(e :: E),a>;
};
recursive type tree[9,1,11,46] {
  con Leaf[10,3,10,6]{0,0,0} : tree;
  con Node[11,3,11,6](left: tree, value: std/core/types/int, right: tree){0,3,8} : (left : tree, value : std/core/types/int, right : tree) -> tree;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:choose` type.
 fun choose/@cfc[6,1,6,13] : forall<(e :: E),a> (^ choose : (choose :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-choose` constructor field of the `:choose` type.
 fun choose/@ctl-choose[7,7,7,21] : forall<(e :: E),a> (^ choose : (choose :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Tests for the `Leaf` constructor of the `:tree` type.
fip fun is-leaf[10,3,10,6] : (^ tree : tree) -> std/core/types/bool;
// Automatically generated. Tests for the `Node` constructor of the `:tree` type.
fip fun is-node[11,3,11,6] : (^ tree : tree) -> std/core/types/bool;
// runtime tag for the effect `:choose`
val @tag-choose[6,1,6,13] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(choose :: (E, V) -> V)>;
// handler for the effect `:choose`
 fun @handle-choose[6,8,6,13] : forall<a,(e :: E),b> (hnd : (choose :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `choose` operation out of effect `:choose`
 fun @select-choose[7,7,7,21] : forall<(e :: E),a> (^ hnd : (choose :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>;
 fun operator[13,5,13,12] : (x : std/core/types/int, y : std/core/types/int) -> std/core/types/int;
// Call the `ctl choose` operation of the effect `:choose`
 fun choose[7,7,7,12] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>> std/core/types/bool;
 fun make[16,5,16,8] : (n : std/core/types/int) -> <(std/core/types/div :: X)> tree;
// monadic lift
 fun @mlift-lift-run@707@10048[1,0,1,0] : forall<(h :: H)> (v : std/core/types/int, @y-x10036 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X)> std/core/types/int;
// monadic lift
 fun @mlift-lift-run@707@10049[1,0,1,0] : forall<(h :: H)> (@y-x10033 : std/core/types/bool, l : tree, r : tree, state : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, v : std/core/types/int, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X)> std/core/types/int;
// monadic lift
 fun @mlift-lift-run@707@10050[1,0,1,0] : forall<(h :: H)> (@y-x10033 : std/core/types/bool, l : tree, r : tree, state : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, v : std/core/types/int, @y-x10034 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X)> std/core/types/int;
// monadic lift
 fun @mlift-lift-run@707@10051[1,0,1,0] : forall<(h :: H)> (l : tree, r : tree, state : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, v : std/core/types/int, @y-x10033 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>> std/core/types/int;
// lifted local: run, explore
 fun @lift-run@707[1,0,1,0] : forall<(h :: H)> (state : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, t : tree) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X)> std/core/types/int;
// lifted local: run, loop
 fun @lift-run@708[1,0,1,0] : forall<(h :: H)> (explore : (t : tree) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>> std/core/types/int, state : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, tree : tree, i : std/core/types/int) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>> std/core/types/int;
 fun run[23,5,23,7] : (n : std/core/types/int) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun main[51,9,51,12] : () -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/ndet :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
recursive specialize "*___"  fun @lift-run@708 // inline size: 17
  = forall<(h :: H)> fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>>(explore: (t : tree) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>> std/core/types/int, state: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, tree: tree, i: std/core/types/int){
    (match ((std/core/int/(==)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat@3: std/core/types/bool)
         -> std/core/types/local-get<std/core/types/int,(h :: H),<(std/core/types/div :: X)>>(state);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@4: std/core/types/bool)
         -> val xs@10015[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/int>
              = main/@handle-choose<std/core/types/int,<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>,(std/core/types/list :: V -> V)<std/core/types/int>>((main/@Hnd-choose<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>,(std/core/types/list :: V -> V)<std/core/types/int>>(3, (std/core/hnd/clause-control0<std/core/types/bool,<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>,(choose :: (E, V) -> V),(std/core/types/list :: V -> V)<std/core/types/int>>((fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>>(resume: (std/core/types/bool) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>> (std/core/types/list :: V -> V)<std/core/types/int>){
                    val xs@0@10017[1,0,1,0] : ((std/core/types/list :: V -> V)<std/core/types/int>)
                      = (resume(std/core/types/True));
                    val ys@10018[1,0,1,0] : ((std/core/types/list :: V -> V)<std/core/types/int>)
                      = (resume(std/core/types/False));
                    (std/core/list/append<std/core/types/int>(xs@0@10017, ys@10018));
                  }))))), (fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>>(x@0: std/core/types/int){
                  (std/core/types/Cons<std/core/types/int>(x@0, (std/core/types/Nil<std/core/types/int>)));
                }), (fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>>(){
                  (explore(tree));
                }));
            val _@0[46,9,46,32] : ()
              = std/core/types/local-set<std/core/types/int,<(std/core/types/div :: X)>,(h :: H)>(state, (match (xs@10015) {
                  ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/int>))
                     -> (match ((std/core/types/@None<std/core/types/int>)) {
                      ((std/core/types/@Optional((@uniq-default@3236: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
                         -> @uniq-default@3236;
                      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
                         -> 0;
                    });
                  ((@skip std/core/types/Cons((x: std/core/types/int) : std/core/types/int, (xx: (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/int>))
                     -> std/core/list/foldl<std/core/types/int,std/core/types/int,(std/core/types/total :: E)>(xx, x, std/core/int/max);
                }));
            val i@0@10019[1,0,1,0] : std/core/types/int
              = std/core/int/int-sub(i, 1);
        main/@lift-run@708<(h :: H)>(explore, state, tree, i@0@10019);
    });
  };
inline borrow "^"  fun choose/@cfc // inline size: 0
  = forall<(e :: E),a> fn(choose@0: (choose :: (E, V) -> V)<(e :: E),a>){
    (match (choose@0) {
      ((@skip main/@Hnd-choose((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) : (choose :: (E, V) -> V)<(e :: E),a> ) as @pat: ((choose :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun choose/@ctl-choose // inline size: 0
  = forall<(e :: E),a> fn(choose@0: (choose :: (E, V) -> V)<(e :: E),a>){
    (match (choose@0) {
      ((@skip main/@Hnd-choose((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) : (choose :: (E, V) -> V)<(e :: E),a> ) as @pat: ((choose :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^" fip fun is-leaf // inline size: 1
  = fn(tree: tree){
    match (tree) {
      ((main/Leaf() : tree ) as @pat: tree)
         -> std/core/types/True;
      ((@skip main/Node((@pat@1: tree) : tree, (@pat@2: std/core/types/int) : std/core/types/int, (@pat@3: tree) : tree) : tree ) as @pat@0: tree)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-node // inline size: 1
  = fn(tree: tree){
    match (tree) {
      ((main/Node((@pat@0: tree) : tree, (@pat@1: std/core/types/int) : std/core/types/int, (@pat@2: tree) : tree) : tree ) as @pat: tree)
         -> std/core/types/True;
      ((@skip main/Leaf() : tree ) as @pat@3: tree)
         -> std/core/types/False;
    };
  };
inline borrow "^"  fun @select-choose // inline size: 0
  = forall<(e :: E),a> fn(hnd: (choose :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-choose((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-choose: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(choose :: (E, V) -> V),(e :: E),a>) : (choose :: (E, V) -> V)<(e :: E),a> ) as @pat: ((choose :: (E, V) -> V)<(e :: E),a>))
         -> @ctl-choose;
    });
  };
inline  fun choose // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>>,(choose :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(choose :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(choose :: (E, V) -> V)>>((std/core/hnd/@evv-at<(choose :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(choose :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-choose);
  };