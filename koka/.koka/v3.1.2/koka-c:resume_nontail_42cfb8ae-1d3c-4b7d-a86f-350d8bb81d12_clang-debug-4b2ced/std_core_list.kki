// Standard `:list` functions.
module interface std/core/list
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/undiv = std/core/undiv = "";
import std/core/hnd = std/core/hnd = "";
import std/core/exn = std/core/exn = "";
import std/core/char = std/core/char = "";
import std/core/string = std/core/string = "";
import std/core/int = std/core/int = "";
import std/core/vector = std/core/vector inline = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// A first-class constructor context where the hole is of the same type as the root of the structure.
local alias std/core/types/ctx[490,1,490,28]<a> :: V -> V = (std/core/types/cctx :: (V, V) -> V)<a,a> = 1;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
// lifted local: concat, concat-pre
 fun @trmc-lift-concat@4788[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, zss : (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// lifted local: concat, concat-pre
 fun @lift-concat@4788[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, zss : (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Concatenate all lists in a list (e.g. flatten the list). (tail-recursive)
pub  fun concat[444,9,444,14] : forall<a> (xss : (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-lift-flatmap@4789@10298[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, zz : (std/core/types/list :: V -> V)<a>, ys@1@10002 : (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
 fun @trmc-lift-flatmap@4789[1,0,1,0] : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, ys : (std/core/types/list :: V -> V)<b>, zs : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
 fun @lift-flatmap@4789[1,0,1,0] : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, ys : (std/core/types/list :: V -> V)<b>, zs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate the result lists from applying a function to all elements.
pub  fun flatmap[454,9,454,15] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: reverse-append, reverse-acc
 fun @lift-reverse-append@4790[1,0,1,0] : forall<a> (acc : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Efficiently reverse a list `xs` and append it to `tl`:
// `reverse-append(xs,tl) == reserve(xs) ++ tl
pub  fun reverse-append[238,9,238,22] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, tl : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Return the head of list if the list is not empty.
pub  fun head[22,9,22,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// lifted local: intersperse, before
 fun @trmc-lift-intersperse@4791[1,0,1,0] : forall<a> (sep : a, ys : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// lifted local: intersperse, before
 fun @lift-intersperse@4791[1,0,1,0] : forall<a> (sep : a, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Insert a separator `sep`  between all elements of a list `xs` .
pub  fun intersperse[404,9,404,19] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, sep : a) -> (std/core/types/list :: V -> V)<a>;
// Is the list empty?
pub  fun is-empty[40,9,40,16] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> std/core/types/bool;
// lifted local: length, len
 fun @lift-length@4792[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, acc : std/core/types/int) -> std/core/types/int;
// Returns the length of a list.
pub  fun length[55,9,55,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> std/core/types/int;
// Convert a `:maybe` type to a list type.
pub  fun maybe/list[355,9,355,18] : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-lift-map-indexed@4793@10299[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (idx : std/core/types/int, value : a) -> (e :: E) b, i@0@10009 : std/core/types/int, yy : (std/core/types/list :: V -> V)<a>, @trmc-x10082 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
 fun @trmc-lift-map-indexed@4793[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
 fun @lift-map-indexed@4793[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
pub  fun map-indexed[207,9,207,19] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (idx : std/core/types/int, value : a) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-lift-map-indexed-peek@4794@10300[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, i@0@10011 : std/core/types/int, yy : (std/core/types/list :: V -> V)<a>, @trmc-x10085 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
 fun @trmc-lift-map-indexed-peek@4794[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
 fun @lift-map-indexed-peek@4794[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
pub  fun map-indexed-peek[225,9,225,24] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-lift-map-peek@4795@10301[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, yy : (std/core/types/list :: V -> V)<a>, @trmc-x10088 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-peek, mappeek
 fun @trmc-lift-map-peek@4795[1,0,1,0] : forall<a,b,(e :: E)> (f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-peek, mappeek
 fun @lift-map-peek@4795[1,0,1,0] : forall<a,b,(e :: E)> (f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
pub  fun map-peek[216,9,216,16] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Returns a singleton list.
pub  fun single[51,9,51,14] : forall<a> (x : a) -> (std/core/types/list :: V -> V)<a>;
// Return the tail of list. Returns the empty list if `xs` is empty.
pub  fun tail[34,9,34,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-lift-zipwith-indexed@4796@10302[1,0,1,0] : forall<a,b,c,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>, f : (std/core/types/int, a, b) -> (e :: E) c, i@0@10013 : std/core/types/int, xx : (std/core/types/list :: V -> V)<a>, yy : (std/core/types/list :: V -> V)<b>, @trmc-x10091 : c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
 fun @trmc-lift-zipwith-indexed@4796[1,0,1,0] : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
 fun @lift-zipwith-indexed@4796[1,0,1,0] : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
pub  fun zipwith-indexed[151,9,151,23] : forall<a,b,c,(e :: E)> (xs0 : (std/core/types/list :: V -> V)<a>, ys0 : (std/core/types/list :: V -> V)<b>, f : (std/core/types/int, a, b) -> (e :: E) c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Return the head of list with a default value in case the list is empty.
pub  fun default/head[28,9,28,20] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, default : a) -> a;
// Append two lists.
pub  fun @trmc-append[250,9,250,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Append two lists.
pub  fun append[250,9,250,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Append two lists.
pub  fun (++)[246,9,246,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Element-wise list equality
pub  fun (==)[97,9,97,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> std/core/types/bool) -> std/core/types/bool;
// Get (zero-based) element `n`  of a list. Return a `:maybe` type.
pub  fun @index[494,9,494,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// monadic lift
 fun @mlift-all@10303[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (std/core/types/list :: V -> V)<a>, @y-x10160 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Do all elements satisfy a predicate ?
pub  fun all[502,9,502,11] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// monadic lift
 fun @mlift-any@10304[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (std/core/types/list :: V -> V)<a>, @y-x10164 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Are there any elements in a list that satisfy a predicate ?
pub  fun any[508,9,508,11] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// Order on lists
pub  fun cmp[107,9,107,11] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, ?cmp : (a, a) -> std/core/types/order) -> std/core/types/order;
// Concatenate a list of `:maybe` values
pub  fun @trmc-concat-maybe[472,9,472,20] : forall<a> (xs : (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Concatenate a list of `:maybe` values
pub  fun concat-maybe[472,9,472,20] : forall<a> (xs : (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Drop the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub  fun drop[194,9,194,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-drop-while@10305[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xs : (std/core/types/list :: V -> V)<a>, xx : (std/core/types/list :: V -> V)<a>, @y-x10168 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Drop all initial elements that satisfy `predicate`
pub  fun drop-while[300,9,300,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-filter@10306[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (std/core/types/list :: V -> V)<a>, @y-x10172 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
pub  fun @trmc-filter[307,9,307,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
pub  fun filter[307,9,307,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-filter-map@10307[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10178 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
pub  fun @trmc-filter-map[332,9,332,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
pub  fun filter-map[332,9,332,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-foreach-while@10308[1,0,1,0] : forall<a,b,(e :: E)> (action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10184 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Invoke `action` for each element of a list while `action` return `Nothing`
pub  fun foreach-while[377,9,377,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
 fun @mlift-find@10309[1,0,1,0] : forall<a,(e :: E)> (x : a, @y-x10188 : std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Find the first element satisfying some predicate
pub  fun find[340,9,340,12] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Find the first element satisfying some predicate and return it.
pub  fun find-maybe[345,9,345,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-flatmap-maybe@10310[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10191 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
pub  fun @trmc-flatmap-maybe[464,9,464,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
pub  fun flatmap-maybe[464,9,464,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-foldl@10311[1,0,1,0] : forall<a,b,(e :: E)> (f : (b, a) -> (e :: E) b, xx : (std/core/types/list :: V -> V)<a>, @y-x10197 : b) -> (e :: E) b;
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
pub  fun foldl[262,9,262,13] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, z : b, f : (b, a) -> (e :: E) b) -> (e :: E) b;
pub  fun foldl1[267,9,267,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a;
// Reverse a list.
pub  fun reverse[233,9,233,15] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
pub  fun foldr[257,9,257,13] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, z : b, f : (a, b) -> (e :: E) b) -> (e :: E) b;
pub  fun foldr1[272,9,272,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a;
// monadic lift
 fun @mlift-foreach@10312[1,0,1,0] : forall<a,(e :: E)> (action : (a) -> (e :: E) (), xx : (std/core/types/list :: V -> V)<a>, wild_ : ()) -> (e :: E) ();
// Invoke `action` for each element of a list
pub  fun foreach[371,9,371,15] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
 fun @mlift-foreach-indexed@10313[1,0,1,0] : forall<(h :: H),(e :: E)> (i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, @y-x10214 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
 fun @mlift-foreach-indexed@10314[1,0,1,0] : forall<(h :: H),(e :: E)> (i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
 fun @mlift-foreach-indexed@10315[1,0,1,0] : forall<(h :: H),a,(e :: E)> (action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, x : a, j : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// Invoke `action` for each element of a list, passing also the position of the element.
pub  fun foreach-indexed[396,9,396,23] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
 fun @mlift-index-of-acc@10316[1,0,1,0] : forall<a,(e :: E)> (idx : std/core/types/int, pred : (a) -> (e :: E) std/core/types/bool, xx : (std/core/types/list :: V -> V)<a>, @y-x10219 : std/core/types/bool) -> (e :: E) std/core/types/int;
 fun index-of-acc[360,5,360,16] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, idx : std/core/types/int) -> (e :: E) std/core/types/int;
// Returns the index of the first element where `pred` holds, or `-1` if no such element exists.
pub  fun index-of[367,9,367,16] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/int;
// Return the list without its last element.
// Return an empty list for an empty list.
pub  fun @trmc-init[488,9,488,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Return the list without its last element.
// Return an empty list for an empty list.
pub  fun init[488,9,488,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// lifted local: joinsep, join-acc
 fun @lift-joinsep@4797[1,0,1,0] : (sep : std/core/types/string, ys : (std/core/types/list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list
 fun joinsep[414,5,414,11] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list
pub  fun join[424,9,424,12] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Append `end` to each string in the list `xs` and join them all together.\
// `join-end([],end) === ""`\
// `join-end(["a","b"],"/") === "a/b/"`
pub  fun join-end[438,9,438,16] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>, end : std/core/types/string) -> std/core/types/string;
// Return the last element of a list (or `Nothing` for the empty list)
pub  fun last[480,9,480,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub  fun @trmc-take[188,9,188,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub  fun take[188,9,188,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/list :: V -> V)<a>;
// split a list at position `n`
pub  fun split[282,9,282,13] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// Split a string into a list of lines
pub  fun lines[531,9,531,13] : (s : std/core/types/string) -> (std/core/types/list :: V -> V)<std/core/types/string>;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun @trmc-list[65,9,65,12] : (lo : std/core/types/int, hi : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/int>>) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun list[65,9,65,12] : (lo : std/core/types/int, hi : std/core/types/int) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// monadic lift
 fun @mlift-trmc-map@10317[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (a) -> (e :: E) b, xx : (std/core/types/list :: V -> V)<a>, @trmc-x10110 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
pub  fun @trmc-map[200,9,200,11] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) b, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
pub  fun map[200,9,200,11] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Create a list of characters from `lo`  to `hi`  (including `hi`).
pub  fun char/list[93,9,93,17] : (lo : std/core/types/char, hi : std/core/types/char) -> (std/core/types/list :: V -> V)<std/core/types/char>;
// monadic lift
 fun function/@mlift-trmc-list@10318[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, @trmc-x10113 : a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun function/@trmc-list[80,9,80,21] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun function/list[80,9,80,21] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stride/@trmc-list[72,9,72,19] : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/int>>) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stride/list[72,9,72,19] : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// monadic lift
 fun stridefunction/@mlift-trmc-list@10319[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, stride : std/core/types/int, @trmc-x10118 : a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stridefunction/@trmc-list[87,9,87,27] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stridefunction/list[87,9,87,27] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Apply a function `f` to each character in a string
pub  fun string/map[539,9,539,18] : forall<(e :: E)> (s : std/core/types/string, f : (std/core/types/char) -> (e :: E) std/core/types/char) -> (e :: E) std/core/types/string;
// monadic lift
 fun @mlift-lookup@10320[1,0,1,0] : forall<a,b,(e :: E)> (kv : (a, b), @y-x10237 : std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Lookup the first element satisfying some predicate
pub  fun lookup[349,9,349,14] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<(a, b)>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-map-while@10321[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10240 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
pub  fun @trmc-map-while[386,9,386,17] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
pub  fun map-while[386,9,386,17] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Returns the largest element of a list of integers (or `default` (=`0`) for the empty list)
pub  fun maximum[524,9,524,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>, default : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Returns the smallest element of a list of integers (or `default` (=`0`) for the empty list)
pub  fun minimum[518,9,518,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>, default : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// monadic lift
 fun @mlift-partition-acc@10322[1,0,1,0] : forall<a,(e :: E)> (acc1 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (std/core/types/list :: V -> V)<a>, @y-x10245 : std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
 fun partition-acc[323,5,323,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ^ pred : (a) -> (e :: E) std/core/types/bool, acc1 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// Partition a list in two lists where the first list contains
// those elements that satisfy the given predicate `pred`.
// For example: `partition([1,2,3],odd?) == ([1,3],[2])`
pub  fun partition[320,9,320,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ^ pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// monadic lift
 fun @mlift-remove@10323[1,0,1,0] : forall<(e :: E)> (@y-x10251 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Remove those elements of a list that satisfy the given predicate `pred`.
// For example: `remove([1,2,3],odd?) == [2]`
pub  fun remove[314,9,314,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Create a list of `n` repeated elements `x`
pub  fun @trmc-replicate[276,9,276,17] : forall<a> (x : a, n : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Create a list of `n` repeated elements `x`
pub  fun replicate[276,9,276,17] : forall<a> (x : a, n : std/core/types/int) -> (std/core/types/list :: V -> V)<a>;
// Concatenate all strings in a list in reverse order
pub  fun reverse-join[432,9,432,20] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Concatenate all strings in a list using a specific separator
pub  fun joinsep/join[428,9,428,20] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
// monadic lift
 fun @mlift-show@10324[1,0,1,0] : forall<(e :: E)> (@y-x10253 : (std/core/types/list :: V -> V)<std/core/types/string>) -> (e :: E) std/core/types/string;
// Show a list
pub  fun show[120,9,120,12] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ?show : (a) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// _deprecated_, use `list/show` instead.
pub  fun show-list[125,9,125,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, show-elem : (a) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// monadic lift
 fun @mlift-lift-span@4798@10325[1,0,1,0] : forall<a,(e :: E)> (acc : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, y : a, ys : (std/core/types/list :: V -> V)<a>, yy : (std/core/types/list :: V -> V)<a>, @y-x10255 : std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// lifted local: span, span-acc
// todo: implement TRMC with multiple results to avoid the reverse
 fun @lift-span@4798[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, ys : (std/core/types/list :: V -> V)<a>, acc : (std/core/types/list :: V -> V)<a>) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
pub  fun span[285,9,285,12] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// Return the sum of a list of integers
pub  fun sum[514,9,514,11] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>) -> std/core/types/int;
// monadic lift
 fun @mlift-trmc-take-while@10326[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, predicate : (a) -> (e :: E) std/core/types/bool, x : a, xx : (std/core/types/list :: V -> V)<a>, @y-x10260 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
pub  fun @trmc-take-while[294,9,294,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
pub  fun take-while[294,9,294,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Join a list of strings with newlines
pub  fun unlines[535,9,535,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// lifted local: unzip, iter
// todo: implement TRMC for multiple results
 fun @lift-unzip@4799[1,0,1,0] : forall<a,b,c,d> (ys : (std/core/types/list :: V -> V)<(a, b)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<c,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<b>>) -> (c, d);
// Unzip a list of pairs into two lists
pub  fun unzip[161,9,161,13] : forall<a,b> (xs : (std/core/types/list :: V -> V)<(a, b)>) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<b>);
// lifted local: unzip3, iter
// todo: implement TRMC for multiple results
 fun @lift-unzip3@4800[1,0,1,0] : forall<a,b,c,d,a1,b1> (ys : (std/core/types/list :: V -> V)<(a, b, c)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<b>>, acc3 : (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<c>>) -> (d, a1, b1);
// Unzip a list of triples into three lists
pub  fun unzip3[170,9,170,14] : forall<a,b,c> (xs : (std/core/types/list :: V -> V)<(a, b, c)>) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<b>, (std/core/types/list :: V -> V)<c>);
// lifted local: unzip4, iter
// todo: implement TRMC for multiple results
 fun @lift-unzip4@4801[1,0,1,0] : forall<a,b,c,d,a1,b1,c1,d1> (ys : (std/core/types/list :: V -> V)<(a, b, c, d)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<b>>, acc3 : (std/core/types/cctx :: (V, V) -> V)<c1,(std/core/types/list :: V -> V)<c>>, acc4 : (std/core/types/cctx :: (V, V) -> V)<d1,(std/core/types/list :: V -> V)<d>>) -> (a1, b1, c1, d1);
// Unzip a list of quadruples into four lists
pub  fun unzip4[179,9,179,14] : forall<a,b,c,d> (xs : (std/core/types/list :: V -> V)<(a, b, c, d)>) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<b>, (std/core/types/list :: V -> V)<c>, (std/core/types/list :: V -> V)<d>);
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
pub  fun @trmc-zip[132,9,132,11] : forall<a,b> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<(a, b)>>) -> (std/core/types/list :: V -> V)<(a, b)>;
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
pub  fun zip[132,9,132,11] : forall<a,b> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>) -> (std/core/types/list :: V -> V)<(a, b)>;
// monadic lift
 fun @mlift-trmc-zipwith@10327[1,0,1,0] : forall<a,b,c,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>, f : (a, b) -> (e :: E) c, xx : (std/core/types/list :: V -> V)<a>, yy : (std/core/types/list :: V -> V)<b>, @trmc-x10129 : c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
pub  fun @trmc-zipwith[141,9,141,15] : forall<a,b,c,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, f : (a, b) -> (e :: E) c, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
pub  fun zipwith[141,9,141,15] : forall<a,b,c,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, f : (a, b) -> (e :: E) c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
recursive specialize "__*"  fun (==) // inline size: 6
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/False;
          ((@skip std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
             -> (match ((@implicit/(==)(x, y))) {
              ((std/core/types/True() : std/core/types/bool ) as @pat@2: std/core/types/bool)
                 -> std/core/list/(==)<a>(xx, yy, @implicit/(==));
              (@pat@3: std/core/types/bool)
                 -> std/core/types/False;
            });
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/True;
          ((@skip std/core/types/Cons((@pat@7: a) : a, (@pat@8: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@6: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/False;
        });
    });
  };
recursive specialize "*__"  fun @lift-flatmap@4789 // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, ys: (std/core/types/list :: V -> V)<b>, zs: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Cons((y: b) : b, (yy: (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b> ) as @pat: ((std/core/types/list :: V -> V)<b>))
         -> std/core/types/Cons<b>(y, (std/core/list/@lift-flatmap@4789<a,b,(e :: E)>(f, yy, zs)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<b> ) as @pat@0: ((std/core/types/list :: V -> V)<b>))
         -> (match (zs) {
          ((std/core/types/Cons((z: a) : a, (zz: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
             -> val ys@1@10002[1,0,1,0] : (std/core/types/list :: V -> V)<b>
                      = f(z);
            std/core/list/@lift-flatmap@4789<a,b,(e :: E)>(f, ys@1@10002, zz);
          ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Nil<b>;
        });
    });
  };
recursive specialize "*__"  fun @lift-map-indexed-peek@4794 // inline size: 7
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> val i@0@10011[1,0,1,0] : std/core/types/int
                  = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y@0: std/core/types/int){
                    (std/core/int/int-add(x, y@0));
                  }))(i, 1);
        std/core/types/Cons<b>((f(i, y, yy)), (std/core/list/@lift-map-indexed-peek@4794<a,b,(e :: E)>(f, yy, i@0@10011)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "*__"  fun @lift-map-indexed@4793 // inline size: 7
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> val i@0@10009[1,0,1,0] : std/core/types/int
                  = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y@0: std/core/types/int){
                    (std/core/int/int-add(x, y@0));
                  }))(i, 1);
        std/core/types/Cons<b>((f(i, y)), (std/core/list/@lift-map-indexed@4793<a,b,(e :: E)>(f, yy, i@0@10009)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "*_"  fun @lift-map-peek@4795 // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Cons<b>((f(y, yy)), (std/core/list/@lift-map-peek@4795<a,b,(e :: E)>(f, yy)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "*__"  fun @lift-span@4798 // inline size: 13
  = forall<a,(e :: E)> fn<(e :: E)>(predicate: (a) -> (e :: E) std/core/types/bool, ys: (std/core/types/list :: V -> V)<a>, acc: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(y))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/list/@lift-span@4798<a,(e :: E)>(predicate, yy, (std/core/types/Cons<a>(y, acc)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs: (std/core/types/list :: V -> V)<a>){
                (std/core/list/@lift-reverse-append@4790<a>((std/core/types/Nil<a>), xs));
              }))(acc)), ys);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@1: (std/core/types/list :: V -> V)<a>){
            (std/core/list/@lift-reverse-append@4790<a>((std/core/types/Nil<a>), xs@1));
          }))(acc)), ys);
    });
  };
recursive specialize "*___"  fun @lift-zipwith-indexed@4796 // inline size: 8
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Cons((y: b) : b, (yy: (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b> ) as @pat@0: ((std/core/types/list :: V -> V)<b>))
             -> val i@0@10013[1,0,1,0] : std/core/types/int
                      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x@0: std/core/types/int, y@0: std/core/types/int){
                        (std/core/int/int-add(x@0, y@0));
                      }))(i, 1);
            std/core/types/Cons<c>((f(i, x, y)), (std/core/list/@lift-zipwith-indexed@4796<a,b,c,(e :: E)>(f, i@0@10013, xx, yy)));
          ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<b> ) as @pat@1: ((std/core/types/list :: V -> V)<b>))
             -> std/core/types/Nil<c>;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
    });
  };
recursive specialize "_*"  fun all // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/list/all<a,(e :: E)>(xx, predicate);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/False;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
    });
  };
recursive specialize "_*"  fun any // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/True;
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/list/any<a,(e :: E)>(xx, predicate);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
recursive specialize "__*"  fun cmp // inline size: 6
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/cmp: (a, a) -> std/core/types/order){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Gt;
          ((@skip std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
             -> (match ((@implicit/cmp(x, y))) {
              ((std/core/types/Eq() : std/core/types/order ) as @pat@2: std/core/types/order)
                 -> std/core/list/cmp<a>(xx, yy, @implicit/cmp);
              (lg: std/core/types/order)
                 -> lg;
            });
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@3: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Eq;
          ((@skip std/core/types/Cons((@pat@6: a) : a, (@pat@7: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Lt;
        });
    });
  };
recursive specialize "_*"  fun drop-while // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/list/drop-while<a,(e :: E)>(xx, predicate);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> xs;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "_*"  fun filter // inline size: 6
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/Cons<a>(x, (std/core/list/filter<a,(e :: E)>(xx, pred)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/list/filter<a,(e :: E)>(xx, pred);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "_*"  fun filter-map // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/list/filter-map<a,b,(e :: E)>(xx, pred);
          ((@skip std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Cons<b>(y, (std/core/list/filter-map<a,b,(e :: E)>(xx, pred)));
        });
    });
  };
specialize "_*"  fun find // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/foreach-while<a,a,(e :: E)>(xs, (fn<(e :: E)>(x: a){
        (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
             -> std/core/types/Just<a>(x);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/Nothing<a>;
        });
      }));
  };
specialize "_*"  fun find-maybe // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    std/core/list/foreach-while<a,b,(e :: E)>(xs, pred);
  };
specialize "_*"  fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/list :: V -> V)<b>){
    std/core/list/@lift-flatmap@4789<a,b,(e :: E)>(f, (std/core/types/Nil<b>), xs);
  };
recursive specialize "_*"  fun flatmap-maybe // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((f(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@0: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Cons<b>(y, (std/core/list/flatmap-maybe<a,b,(e :: E)>(xx, f)));
          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/list/flatmap-maybe<a,b,(e :: E)>(xx, f);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "__*"  fun foldl // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (b, a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/foldl<a,b,(e :: E)>(xx, (f(z, x)), f);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> z;
    });
  };
specialize "_*"  fun foldl1 // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xs: (std/core/types/list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/foldl<a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xx, x, f);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a>((std/core/exn/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
specialize "__*"  fun foldr // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    std/core/list/foldl<a,b,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@0: (std/core/types/list :: V -> V)<a>){
        (std/core/list/@lift-reverse-append@4790<a>((std/core/types/Nil<a>), xs@0));
      }))(xs)), z, (fn<(e :: E)>(x: b, y: a){
        (f(y, x));
      }));
  };
specialize "_*"  fun foldr1 // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xs: (std/core/types/list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a){
    val xs@0@10024[1,0,1,0] : (std/core/types/list :: V -> V)<a>
          = std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>>((fn(xs@1: (std/core/types/list :: V -> V)<a>){
            (std/core/list/@lift-reverse-append@4790<a>((std/core/types/Nil<a>), xs@1));
          }))(xs);
    (match (xs@0@10024) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/foldl<a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xx, x, f);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a>((std/core/exn/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
recursive specialize "_*"  fun foreach // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) ()){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> val _[373,21,373,29] : ()
                  = action(x);
        std/core/list/foreach<a,(e :: E)>(xx, action);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Unit;
    });
  };
specialize "_*"  fun foreach-indexed // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (std/core/types/int, a) -> (e :: E) ()){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (() -> (e :: E) ()),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (e :: E) (() -> (e :: E) ())>((std/core/types/unsafe-no-local-cast<(),(e :: E)>))((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(){
      std/core/hnd/local-var<std/core/types/int,(),(e :: E),(h :: H)>(0, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(i: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>){
          (std/core/list/foreach<a,<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(xs, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(x: a){
              val j[399,9,399,9] : std/core/types/int
                = (std/core/types/local-get<std/core/types/int,(h :: H),(e :: E)>(i));
              val _[400,5,400,15] : ()
                = (std/core/hnd/@mask-builtin<(),(e :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>((fn<(e :: E)>(){
                  (action(j, x));
                })));
              (std/core/types/local-set<std/core/types/int,(e :: E),(h :: H)>(i, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> std/core/types/int>((fn(x@0: std/core/types/int, y: std/core/types/int){
                  (std/core/int/int-add(x@0, y));
                }))((std/core/types/local-get<std/core/types/int,(h :: H),(e :: E)>(i)), 1))));
            })));
        }));
    }))();
  };
recursive specialize "_*"  fun foreach-while // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/list/foreach-while<a,b,(e :: E)>(xx, action);
          (just: ((std/core/types/maybe :: V -> V)<b>))
             -> just;
        });
    });
  };
specialize "_*"  fun index-of // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/index-of-acc<a,(e :: E)>(xs, pred, 0);
  };
recursive specialize "_*_"  fun index-of-acc // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> idx;
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/list/index-of-acc<a,(e :: E)>(xx, pred, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x@0: std/core/types/int, y: std/core/types/int){
                (std/core/int/int-add(x@0, y));
              }))(idx, 1)));
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> -1;
    });
  };
specialize "_*"  fun lookup // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<(a, b)>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/foreach-while<(a, b),b,(e :: E)>(xs, (fn<(e :: E)>(kv: (a, b)){
        (match ((pred((std/core/types/@open<(std/core/types/total :: E),(e :: E),(tuple2 : (a, b)) -> a,(tuple2 : (a, b)) -> (e :: E) a>((fn(tuple2: (a, b)){
          (match (tuple2) {
            ((@skip std/core/types/Tuple2((@x: a) : a, (@pat@0: b) : b) : (a, b) ) as @pat: (a, b))
               -> @x;
          });
        }))(kv))))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Just<b>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(tuple2 : (a, b)) -> b,(tuple2 : (a, b)) -> (e :: E) b>((fn(tuple2@0: (a, b)){
              (match (tuple2@0) {
                ((@skip std/core/types/Tuple2((@pat@0@0: a) : a, (@x@0: b) : b) : (a, b) ) as @pat@2: (a, b))
                   -> @x@0;
              });
            }))(kv)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@1: std/core/types/bool)
             -> std/core/types/Nothing<b>;
        });
      }));
  };
recursive specialize "_*"  fun map // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Cons<b>((f(x)), (std/core/list/map<a,b,(e :: E)>(xx, f)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
specialize "_*"  fun map-indexed // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    std/core/list/@lift-map-indexed@4793<a,b,(e :: E)>(f, xs, 0);
  };
specialize "_*"  fun map-indexed-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    std/core/list/@lift-map-indexed-peek@4794<a,b,(e :: E)>(f, xs, 0);
  };
specialize "_*"  fun map-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    std/core/list/@lift-map-peek@4795<a,b,(e :: E)>(f, xs);
  };
recursive specialize "_*"  fun map-while // inline size: 5
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Cons<b>(y, (std/core/list/map-while<a,b,(e :: E)>(xx, action)));
          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Nil<b>;
        });
    });
  };
specialize "_*" borrow "_^"  fun partition // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/partition-acc<a,(e :: E)>(xs, pred, (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>()), (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>()));
  };
recursive specialize "_*__" borrow "_^__"  fun partition-acc // inline size: 24
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, acc1: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1, (std/core/types/Nil<a>))), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2, (std/core/types/Nil<a>))));
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> val @cctx-x3377[1,0,1,0] : (std/core/types/list :: V -> V)<a>
                  = std/core/types/Cons<a>(x, (std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> (std/core/types/list :: V -> V)<a>,() -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/@cctx-hole-create<(std/core/types/list :: V -> V)<a>>))()));
                val @cctx-x3378[1,0,1,0] : (std/core/types/@field-addr :: V -> V)<(std/core/types/list :: V -> V)<a>>
                  = std/core/types/@field-addr-of<(std/core/types/list :: V -> V)<a>>(@cctx-x3377, "(\x22std/core/types\x22,\x22\x22,\x22Cons\x22)", "(\x22\x22,\x22\x22,\x22tail\x22)");
            std/core/list/partition-acc<a,(e :: E)>(xx, pred, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>,(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>>((std/core/types/#cctx/(++)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1, (std/core/types/@cctx-create<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(@cctx-x3377, @cctx-x3378)))), acc2);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
             -> val @cctx-x3420[1,0,1,0] : (std/core/types/list :: V -> V)<a>
                  = std/core/types/Cons<a>(x, (std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> (std/core/types/list :: V -> V)<a>,() -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/@cctx-hole-create<(std/core/types/list :: V -> V)<a>>))()));
                val @cctx-x3421[1,0,1,0] : (std/core/types/@field-addr :: V -> V)<(std/core/types/list :: V -> V)<a>>
                  = std/core/types/@field-addr-of<(std/core/types/list :: V -> V)<a>>(@cctx-x3420, "(\x22std/core/types\x22,\x22\x22,\x22Cons\x22)", "(\x22\x22,\x22\x22,\x22tail\x22)");
            std/core/list/partition-acc<a,(e :: E)>(xx, pred, acc1, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>,(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>>((std/core/types/#cctx/(++)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2, (std/core/types/@cctx-create<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(@cctx-x3420, @cctx-x3421)))));
        });
    });
  };
specialize "_*"  fun remove // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/filter<a,(e :: E)>(xs, (fn<(e :: E)>(x: a){
        (std/core/types/@open<(std/core/types/total :: E),(e :: E),(b : std/core/types/bool) -> std/core/types/bool,(b : std/core/types/bool) -> (e :: E) std/core/types/bool>((fn(b: std/core/types/bool){
          (match (b) {
            ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
               -> std/core/types/False;
            ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
               -> std/core/types/True;
          });
        }))((pred(x))));
      }));
  };
specialize "_*"  fun show // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, @implicit/show: (a) -> (e :: E) std/core/types/string){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> (e :: E) std/core/types/string>(std/core/types/(++))("[", (std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> (e :: E) std/core/types/string>(std/core/types/(++))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string,(xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> (e :: E) std/core/types/string>((fn(xs@0: (std/core/types/list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
          (match (xs@0) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> "";
            ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> std/core/list/@lift-joinsep@4797(sep, xx, x);
          });
        }))((std/core/list/map<a,std/core/types/string,(e :: E)>(xs, @implicit/show)), ",")), "]")));
  };
specialize "_*"  fun show-list // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, show-elem: (a) -> (e :: E) std/core/types/string){
    std/core/list/show<a,(e :: E)>(xs, show-elem);
  };
specialize "_*"  fun span // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    std/core/list/@lift-span@4798<a,(e :: E)>(predicate, xs, (std/core/types/Nil<a>));
  };
recursive specialize "_*"  fun take-while // inline size: 5
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/Cons<a>(x, (std/core/list/take-while<a,(e :: E)>(xx, predicate)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Nil<a>;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "__*"  fun zipwith // inline size: 5
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Cons((y: b) : b, (yy: (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b> ) as @pat@0: ((std/core/types/list :: V -> V)<b>))
             -> std/core/types/Cons<c>((f(x, y)), (std/core/list/zipwith<a,b,c,(e :: E)>(xx, yy, f)));
          ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<b> ) as @pat@1: ((std/core/types/list :: V -> V)<b>))
             -> std/core/types/Nil<c>;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
    });
  };
specialize "__*"  fun zipwith-indexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (std/core/types/list :: V -> V)<a>, ys0: (std/core/types/list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    std/core/list/@lift-zipwith-indexed@4796<a,b,c,(e :: E)>(f, 0, xs0, ys0);
  };
recursive specialize "__*"  fun function/list // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/int/(<=))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Cons<a>((f(lo)), (std/core/list/#function/list<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/undiv/pretend-decreasing<std/core/types/int>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
              (std/core/int/int-add(i, 1));
            }))(lo)))), hi, f)));
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "___*"  fun stridefunction/list // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, stride: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/int/(<=))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Cons<a>((f(lo)), (std/core/list/#stridefunction/list<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/undiv/pretend-decreasing<std/core/types/int>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y: std/core/types/int){
              (std/core/int/int-add(x, y));
            }))(lo, stride)))), hi, stride, f)));
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/Nil<a>;
    });
  };
specialize "_*"  fun string/map // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, f: (std/core/types/char) -> (e :: E) std/core/types/char){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> std/core/types/string,(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> (e :: E) std/core/types/string>(std/core/string/#listchar/string)((std/core/list/map<std/core/types/char,std/core/types/char,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(s : std/core/types/string) -> (std/core/types/list :: V -> V)<std/core/types/char>,(s : std/core/types/string) -> (e :: E) (std/core/types/list :: V -> V)<std/core/types/char>>(std/core/string/list)(s)), f)));
  };
 fun concat // inline size: 1
  = forall<a> fn(xss: (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    std/core/list/@lift-concat@4788<a>((std/core/types/Nil<a>), xss);
  };
 fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/list :: V -> V)<b>){
    std/core/list/@lift-flatmap@4789<a,b,(e :: E)>(f, (std/core/types/Nil<b>), xs);
  };
 fun reverse-append // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, tl: (std/core/types/list :: V -> V)<a>){
    std/core/list/@lift-reverse-append@4790<a>(tl, xs);
  };
 fun head // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (@pat@0: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
    });
  };
 fun intersperse // inline size: 3
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, sep: a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Cons<a>(x, (std/core/list/@lift-intersperse@4791<a>(sep, xx)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
 fun is-empty // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
 fun length // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    std/core/list/@lift-length@4792<a>(xs, 0);
  };
 fun maybe/list // inline size: 2
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      ((@skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Cons<a>(x, (std/core/types/Nil<a>));
    });
  };
 fun map-indexed // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    std/core/list/@lift-map-indexed@4793<a,b,(e :: E)>(f, xs, 0);
  };
 fun map-indexed-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    std/core/list/@lift-map-indexed-peek@4794<a,b,(e :: E)>(f, xs, 0);
  };
 fun map-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    std/core/list/@lift-map-peek@4795<a,b,(e :: E)>(f, xs);
  };
 fun single // inline size: 1
  = forall<a> fn(x: a){
    std/core/types/Cons<a>(x, (std/core/types/Nil<a>));
  };
 fun tail // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Cons((@pat@0: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> xx;
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
 fun zipwith-indexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (std/core/types/list :: V -> V)<a>, ys0: (std/core/types/list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    std/core/list/@lift-zipwith-indexed@4796<a,b,c,(e :: E)>(f, 0, xs0, ys0);
  };
 fun default/head // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, default: a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (@pat@0: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> x;
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> default;
    });
  };
 fun (++) // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>){
    std/core/list/append<a>(xs, ys);
  };
 fun find // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/foreach-while<a,a,(e :: E)>(xs, (fn<(e :: E)>(x: a){
        (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
             -> std/core/types/Just<a>(x);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/Nothing<a>;
        });
      }));
  };
 fun find-maybe // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    std/core/list/foreach-while<a,b,(e :: E)>(xs, pred);
  };
 fun foldl1 // inline size: 4
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xs: (std/core/types/list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/foldl<a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xx, x, f);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a>((std/core/exn/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
 fun reverse // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    std/core/list/@lift-reverse-append@4790<a>((std/core/types/Nil<a>), xs);
  };
 fun index-of // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/index-of-acc<a,(e :: E)>(xs, pred, 0);
  };
 fun joinsep // inline size: 2
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/list/@lift-joinsep@4797(sep, xx, x);
    };
  };
 fun join // inline size: 2
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/list/@lift-joinsep@4797("", xx, x);
    };
  };
 fun join-end // inline size: 4
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>, end: std/core/types/string){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      (@pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/types/(++)((match (xs) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> "";
            ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> std/core/list/@lift-joinsep@4797(end, xx, x);
          }), end);
    };
  };
 fun split // inline size: 3
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, n: std/core/types/int){
    std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/list/take<a>(xs, n)), (std/core/list/drop<a>(xs, n)));
  };
 fun lines // inline size: 2
  = fn(s: std/core/types/string){
    val v@10012[1,0,1,0] : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/string/splitv(s, "\x0A");
    std/core/vector/vlist<std/core/types/string>(v@10012, (std/core/types/@None<(std/core/types/list :: V -> V)<std/core/types/string>>));
  };
 fun char/list // inline size: 4
  = fn(lo: std/core/types/char, hi: std/core/types/char){
    std/core/list/map<std/core/types/int,std/core/types/char,(std/core/types/total :: E)>((std/core/list/list((std/core/char/int(lo)), (std/core/char/int(hi)))), std/core/char/#int/char);
  };
 fun maximum // inline size: 3
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>, default: (std/core/types/@optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> (match (default) {
          ((std/core/types/@Optional((@uniq-default@3236: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> @uniq-default@3236;
          ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((@skip std/core/types/Cons((x: std/core/types/int) : std/core/types/int, (xx: (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> std/core/list/foldl<std/core/types/int,std/core/types/int,(std/core/types/total :: E)>(xx, x, std/core/int/max);
    };
  };
 fun minimum // inline size: 3
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>, default: (std/core/types/@optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> (match (default) {
          ((std/core/types/@Optional((@uniq-default@3266: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> @uniq-default@3266;
          ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((@skip std/core/types/Cons((x: std/core/types/int) : std/core/types/int, (xx: (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> std/core/list/foldl<std/core/types/int,std/core/types/int,(std/core/types/total :: E)>(xx, x, std/core/int/min);
    };
  };
borrow "_^"  fun partition // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/list/partition-acc<a,(e :: E)>(xs, pred, (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>()), (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>()));
  };
 fun reverse-join // inline size: 3
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>){
    val xs@0@10045[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/string>
          = std/core/list/@lift-reverse-append@4790<std/core/types/string>((std/core/types/Nil<std/core/types/string>), xs);
    match (xs@0@10045) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/list/@lift-joinsep@4797("", xx, x);
    };
  };
 fun joinsep/join // inline size: 2
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/list/@lift-joinsep@4797(sep, xx, x);
    };
  };
 fun show-list // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, show-elem: (a) -> (e :: E) std/core/types/string){
    std/core/list/show<a,(e :: E)>(xs, show-elem);
  };
 fun span // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    std/core/list/@lift-span@4798<a,(e :: E)>(predicate, xs, (std/core/types/Nil<a>));
  };
 fun sum // inline size: 1
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>){
    std/core/list/foldl<std/core/types/int,std/core/types/int,(std/core/types/total :: E)>(xs, 0, std/core/int/(+));
  };
 fun unlines // inline size: 2
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/list/@lift-joinsep@4797("\x0A", xx, x);
    };
  };
 fun unzip // inline size: 3
  = forall<a,b> fn(xs: (std/core/types/list :: V -> V)<(a, b)>){
    std/core/list/@lift-unzip@4799<a,b,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>>(xs, (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>()), (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<b>>()));
  };
 fun unzip3 // inline size: 4
  = forall<a,b,c> fn(xs: (std/core/types/list :: V -> V)<(a, b, c)>){
    std/core/list/@lift-unzip3@4800<a,b,c,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<c>>(xs, (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>()), (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<b>>()), (std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<c>>()));
  };