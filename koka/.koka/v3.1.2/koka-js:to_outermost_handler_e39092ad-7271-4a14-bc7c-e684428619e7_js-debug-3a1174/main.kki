module interface main
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/os/env = std/os/env = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// Index into an evidence vector
local alias std/core/hnd/ev-index[139,1,139,28] = std/core/types/ssize_t = 1;
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// ctl get
// ctl set
// ```
recursive effect type state[5,1,5,12] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-state[5,1,5,12](@cfc: std/core/types/int, @ctl-get: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, @ctl-set: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>){0,3,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) -> (state :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// ctl yield
// ```
recursive effect type yield[9,1,9,12] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-yield[9,1,9,12](@cfc: std/core/types/int, @ctl-yield: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) -> (yield :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:state` type.
 fun state/@cfc[5,1,5,12] : forall<(e :: E),a> (^ state : (state :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-get` constructor field of the `:state` type.
 fun state/@ctl-get[6,7,6,16] : forall<(e :: E),a> (^ state : (state :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@ctl-set` constructor field of the `:state` type.
 fun state/@ctl-set[7,7,7,22] : forall<(e :: E),a> (^ state : (state :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:yield` type.
 fun yield/@cfc[9,1,9,12] : forall<(e :: E),a> (^ yield : (yield :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-yield` constructor field of the `:yield` type.
 fun yield/@ctl-yield[10,7,10,25] : forall<(e :: E),a> (^ yield : (yield :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>;
// runtime tag for the effect `:state`
val @tag-state[5,1,5,12] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(state :: (E, V) -> V)>;
// handler for the effect `:state`
 fun @handle-state[5,8,5,12] : forall<a,(e :: E),b> (hnd : (state :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// runtime tag for the effect `:yield`
val @tag-yield[9,1,9,12] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(yield :: (E, V) -> V)>;
// handler for the effect `:yield`
 fun @handle-yield[9,8,9,12] : forall<a,(e :: E),b> (hnd : (yield :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `get` operation out of effect `:state`
 fun @select-get[6,7,6,16] : forall<(e :: E),a> (^ hnd : (state :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>;
// select `set` operation out of effect `:state`
 fun @select-set[7,7,7,22] : forall<(e :: E),a> (^ hnd : (state :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>;
// select `yield` operation out of effect `:yield`
 fun @select-yield[10,7,10,25] : forall<(e :: E),a> (^ hnd : (yield :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>;
// Call the `ctl get` operation of the effect `:state`
 fun get[6,7,6,9] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> std/core/types/int;
// Call the `ctl set` operation of the effect `:state`
 fun set[7,7,7,9] : (i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-countdown@10042[1,0,1,0] : (wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-countdown@10043[1,0,1,0] : (i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> std/core/types/int;
 fun countdown[12,5,12,13] : () -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> std/core/types/int;
 fun shandler[27,5,27,12] : forall<a,(e :: E)> (n : std/core/types/int, body : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) a;
// monadic lift
 fun @mlift-pad@10044[1,0,1,0] : forall<a,(e :: E)> (body : () -> <(std/core/types/div :: X)|(e :: E)> a, d : std/core/types/int, @y-x10030 : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>,(std/core/types/div :: X)|(e :: E)> a;
 fun pad[20,5,20,7] : forall<a,(e :: E)> (d : std/core/types/int, body : () -> <(std/core/types/div :: X)|(e :: E)> a) -> <(std/core/types/div :: X)|(e :: E)> a;
 fun run[35,5,35,7] : (n : std/core/types/int, d : std/core/types/int) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun main[38,9,38,12] : () -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/ndet :: X)> ();
// Call the `ctl yield` operation of the effect `:yield`
 fun yield[10,7,10,11] : (i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
recursive specialize "_*"  fun pad // inline size: 11
  = forall<a,(e :: E)> fn<<(std/core/types/div :: X)|(e :: E)>>(d: std/core/types/int, body: () -> <(std/core/types/div :: X)|(e :: E)> a){
    (match ((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X)|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool>(std/core/int/(==))(d, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> body();
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> main/shandler<a,<(std/core/types/div :: X)|(e :: E)>>(-377, (fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>,(std/core/types/div :: X)|(e :: E)>>(){
            (std/core/hnd/@mask-at<a,<(std/core/types/div :: X)|(e :: E)>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>,(std/core/types/div :: X)|(e :: E)>>((std/core/hnd/@evv-index<<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>,(std/core/types/div :: X)|(e :: E)>>(main/@tag-state)), std/core/types/False, (fn<<(std/core/types/div :: X)|(e :: E)>>(){
                (main/pad<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X)|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/div :: X)|(e :: E)> std/core/types/int>((fn(x: std/core/types/int, y: std/core/types/int){
                    (std/core/int/int-sub(x, y));
                  }))(d, 1)), body));
              })));
          }));
    });
  };
inline borrow "^"  fun state/@cfc // inline size: 0
  = forall<(e :: E),a> fn(state: (state :: (E, V) -> V)<(e :: E),a>){
    (match (state) {
      ((@skip main/@Hnd-state((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (state :: (E, V) -> V)<(e :: E),a> ) as @pat: ((state :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun state/@ctl-get // inline size: 0
  = forall<(e :: E),a> fn(state: (state :: (E, V) -> V)<(e :: E),a>){
    (match (state) {
      ((@skip main/@Hnd-state((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (state :: (E, V) -> V)<(e :: E),a> ) as @pat: ((state :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun state/@ctl-set // inline size: 0
  = forall<(e :: E),a> fn(state: (state :: (E, V) -> V)<(e :: E),a>){
    (match (state) {
      ((@skip main/@Hnd-state((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (state :: (E, V) -> V)<(e :: E),a> ) as @pat: ((state :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun yield/@cfc // inline size: 0
  = forall<(e :: E),a> fn(yield@0: (yield :: (E, V) -> V)<(e :: E),a>){
    (match (yield@0) {
      ((@skip main/@Hnd-yield((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) : (yield :: (E, V) -> V)<(e :: E),a> ) as @pat: ((yield :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun yield/@ctl-yield // inline size: 0
  = forall<(e :: E),a> fn(yield@0: (yield :: (E, V) -> V)<(e :: E),a>){
    (match (yield@0) {
      ((@skip main/@Hnd-yield((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) : (yield :: (E, V) -> V)<(e :: E),a> ) as @pat: ((yield :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun @select-get // inline size: 0
  = forall<(e :: E),a> fn(hnd: (state :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-state((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-get: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (state :: (E, V) -> V)<(e :: E),a> ) as @pat: ((state :: (E, V) -> V)<(e :: E),a>))
         -> @ctl-get;
    });
  };
inline borrow "^"  fun @select-set // inline size: 0
  = forall<(e :: E),a> fn(hnd: (state :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-state((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int,(state :: (E, V) -> V),(e :: E),a>, (@ctl-set: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(state :: (E, V) -> V),(e :: E),a>) : (state :: (E, V) -> V)<(e :: E),a> ) as @pat: ((state :: (E, V) -> V)<(e :: E),a>))
         -> @ctl-set;
    });
  };
inline borrow "^"  fun @select-yield // inline size: 0
  = forall<(e :: E),a> fn(hnd: (yield :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-yield((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-yield: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(yield :: (E, V) -> V),(e :: E),a>) : (yield :: (E, V) -> V)<(e :: E),a> ) as @pat: ((yield :: (E, V) -> V)<(e :: E),a>))
         -> @ctl-yield;
    });
  };
inline  fun get // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<std/core/types/int,<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>,(state :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(state :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(state :: (E, V) -> V)>>((std/core/hnd/@evv-at<(state :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-get);
  };
inline  fun set // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>>(i: std/core/types/int){
    std/core/hnd/@perform1<std/core/types/int,(),(state :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(state :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(state :: (E, V) -> V)>>((std/core/hnd/@evv-at<(state :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-set, i);
  };
 fun run // inline size: 2
  = fn<<(std/core/types/div :: X)>>(n: std/core/types/int, d: std/core/types/int){
    main/shandler<std/core/types/int,<(std/core/types/div :: X)>>(n, (fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>,(std/core/types/div :: X)>>(){
        (main/pad<std/core/types/int,<(std/core/types/handled :: ((E, V) -> V) -> X)<(state :: (E, V) -> V)>>>(d, main/countdown));
      }));
  };
inline  fun yield // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>>>(i: std/core/types/int){
    std/core/hnd/@perform1<std/core/types/int,(),(yield :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(yield :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(yield :: (E, V) -> V)>>((std/core/hnd/@evv-at<(yield :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(yield :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-yield, i);
  };