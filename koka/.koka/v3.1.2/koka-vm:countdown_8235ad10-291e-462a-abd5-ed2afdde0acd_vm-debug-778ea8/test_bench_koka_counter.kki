module interface test/bench/koka/counter
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/num/int32 = std/num/int32 = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// fun get
// fun set
// ```
pub recursive linear effect type st[3,1,3,16] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-st[3,1,3,16](@cfc: std/core/types/int, @fun-get: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, @fun-set: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>){0,3,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) -> (st :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:st` type.
 fun st/@cfc[3,1,3,16] : forall<(e :: E),a> (^ st : (st :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-get` constructor field of the `:st` type.
 fun st/@fun-get[4,7,4,19] : forall<(e :: E),a> (^ st : (st :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-set` constructor field of the `:st` type.
 fun st/@fun-set[5,7,5,26] : forall<(e :: E),a> (^ st : (st :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>;
// runtime tag for the effect `:st`
pub val @tag-st[3,1,3,16] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(st :: (E, V) -> V)>;
// handler for the effect `:st`
pub  fun @handle-st[3,15,3,16] : forall<a,(e :: E),b> (hnd : (st :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `get` operation out of effect `:st`
pub  fun @select-get[4,7,4,19] : forall<(e :: E),a> (^ hnd : (st :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>;
// select `set` operation out of effect `:st`
pub  fun @select-set[5,7,5,26] : forall<(e :: E),a> (^ hnd : (st :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>;
// Call the `fun get` operation of the effect `:st`
pub  fun get[4,7,4,9] : () -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> std/core/types/int32;
// Call the `fun set` operation of the effect `:st`
pub  fun set[5,7,5,9] : (i : std/core/types/int32) -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> ();
pub  fun counter[13,5,13,11] : (c : std/core/types/int32) -> <(std/core/types/div :: X),(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> std/core/types/int;
pub  fun state[7,5,7,9] : forall<a,(e :: E)> (i : std/core/types/int32, action : () -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) a;
pub  fun main[19,9,19,12] : () -> <(std/core/console/console :: X),(std/core/types/div :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun st/@cfc // inline size: 0
  = forall<(e :: E),a> fn(st: (st :: (E, V) -> V)<(e :: E),a>){
    (match (st) {
      ((@skip test/bench/koka/counter/@Hnd-st((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (st :: (E, V) -> V)<(e :: E),a> ) as @pat: ((st :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun st/@fun-get // inline size: 0
  = forall<(e :: E),a> fn(st: (st :: (E, V) -> V)<(e :: E),a>){
    (match (st) {
      ((@skip test/bench/koka/counter/@Hnd-st((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (st :: (E, V) -> V)<(e :: E),a> ) as @pat: ((st :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun st/@fun-set // inline size: 0
  = forall<(e :: E),a> fn(st: (st :: (E, V) -> V)<(e :: E),a>){
    (match (st) {
      ((@skip test/bench/koka/counter/@Hnd-st((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (st :: (E, V) -> V)<(e :: E),a> ) as @pat: ((st :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun @select-get // inline size: 0
  = forall<(e :: E),a> fn(hnd: (st :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip test/bench/koka/counter/@Hnd-st((@pat@0: std/core/types/int) : std/core/types/int, (@fun-get: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (st :: (E, V) -> V)<(e :: E),a> ) as @pat: ((st :: (E, V) -> V)<(e :: E),a>))
         -> @fun-get;
    });
  };
inline borrow "^"  fun @select-set // inline size: 0
  = forall<(e :: E),a> fn(hnd: (st :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip test/bench/koka/counter/@Hnd-st((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(st :: (E, V) -> V),(e :: E),a>, (@fun-set: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int32,(),(st :: (E, V) -> V),(e :: E),a>) : (st :: (E, V) -> V)<(e :: E),a> ) as @pat: ((st :: (E, V) -> V)<(e :: E),a>))
         -> @fun-set;
    });
  };
inline  fun get // inline size: 5
  = fn<<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<std/core/types/int32,<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>,(st :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(st :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(st :: (E, V) -> V)>>((std/core/hnd/@evv-at<(st :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), test/bench/koka/counter/@select-get);
  };
inline  fun set // inline size: 5
  = fn<<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>>(i: std/core/types/int32){
    std/core/hnd/@perform1<std/core/types/int32,(),(st :: (E, V) -> V),<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(st :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(st :: (E, V) -> V)>>((std/core/hnd/@evv-at<(st :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled1 :: ((E, V) -> V) -> X)<(st :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), test/bench/koka/counter/@select-set, i);
  };