/* Internal effect handler primitives.
 
  Internal primitives to implement evidence based algebraic
  effect handlers. These are emitted by the compiler during evidence
  translation and this module is always implicitly imported.

  This module is compiled _without monadic translation_ and
  thus we need to do this by hand in this module which allows us to implement
  most primitives directly in Koka keeping the external C/JavaScript/etc primitives
  to a minimum.

  The paper:

  > Ningning Xie, and Daan Leijen. _Generalized Evidence Passing for Effect Handlers_,
  > or _efficient compilation of effect handlers to C_.
  > Proceedings of the ACM International Conference on Functional Programming (ICFP'21),
  > August 2021, Vol 5: pp. 71, doi: 10.1145/3473576.
  > <https://www.microsoft.com/en-us/research/publication/generalized-evidence-passing-for-effect-handlers-or-efficient-compilation-of-effect-handlers-to-c/>

  describes precisely how the monadic evidence translation works on which this
  module is based. Read this first to understand how this module works.

  Another paper of interest is:

  > Ningning Xie, and Daan Leijen. _Effect Handlers in Haskell, Evidently_.
  > The 13th ACM SIGPLAN International Haskell Symposium, (Haskell'20),
  > August 2020. <https://www.microsoft.com/en-us/research/uploads/prod/2020/07/effev.pdf>

  which which explains the internal typing of handlers, evidence vectors, etc. in a simpler setting.

  ## Notes

  An effect _row_ has kind `::E`, while an atomic effect kind is `::X`.
  (We will see that `::X` is equal to the kind `::(E,V) -> V` ) (`::V` is for value kinds *)

  We use the term "answer" context to talk about the result type `:r` and effect type `:e` of
  (the context of) the handler in the stack. The `:e` does not include the effect `::X` of the handler.

  - `:marker<e,r>` : a unique integer corresponding to an answer context `:<e,r>`. This functions
    as a dependent type: when the integer matches at runtime, that will be the type of the answer context.

  - handlers `:h` are partially applied types with signature `h<e,r> :: (E,V)->V`
    for some answer context `:<e,r>`. The handlers contain all operations (much like a virtual method table).
    (these handler types are generated by the compiler for each effect type)

  - Evidence `ev<h :: (E,V)->V >` for a handler `:h` is an existential tuple
    `forall e r. Ev( marker: marker<e,r>, hnd: h<e,r> )` containing the marker and the actual handler (pointer)
    for some answer context `:<e,r>` -- we don't know the answer context exact type as it depends on where
    the handler was dynamically bound; we just have evidence that this handler `:h` exists in our context.

  - Actually, we use a quadruple for the evidence (corresponding to the evidence as formalized in the generalized evidence paper).
    We also add the handler effect tag (`:htag<h>`) (for dynamic lookup), and the evidence vector
    of the answer context where the handler was defind (`:evv<e,r>`)
    (so we can execute operations in-place using the evidence vector at the point where they were defined).

  - Each operation definition in a handler is called a _clause_. For a one argument operation, we have:
    ```
    abstract value type clause1<a,b,h,e::E,r>
      Clause1( clause: (marker<e,r>, ev<h>, a) -> e b )
    ```
    defining an operation `:a -> b` for some handler `:h` in an answer context `:<e,r>`.
    (these are generated by the compiler from a handler definition)

  - An operation is performed by a rank-2 function:
    `fun perform1( ev : ev<h>, select-op : (forall<e1,r> h<e1,r> -> clause1<a,b,h,e1,r>), x : a ) : e b`
    where we can call an operation given evidence for a handler `:ev<h>` together with a
    polymorphic field selection function that for any handler `h` in _any_ answer context, returns its clause.
    It is defined as:
    ```
      match ev
        Ev(_tag,m,h,_answ) -> match select-op(h)  // for an abstract `:<e1,r>`
          Clause1(f) -> f(m,ev,x)
    ```

  - Each clause _definition_ can now determine to fully yield to the handler, or be tail-resumptive etc.
    (that is, this is determined at the handler definition site, not the call site, and generated by the compiler)
    For example, we could be most general (`ctl`) and yield back to the marker (where the handler was defined in the call-stack)
    (with a function that receives the continuation/resumption `k`):
    ```
    Clause1( fn(m,ev,x) yield-to(m, fn(k) op(k,x) ))
    ```
    or be super efficient and directly call the (tail-resumptive) operation in-place (`fun`):
    ```
    Clause1( fn(m,ev,x) op(x) )
    ```
    and various variants in-between. The last definition is unsafe for example if the (user defined) `op` invokes
    operations itself as the evidence vector should be the one as defined at the handler site.
    So, we norally use instead:
    ```
    Clause1( fn(m,ev,x) under1(ev,op,x) )
    ```
    where `under1` uses the evidence vector (`hevv`) stored in the evidence `ev` to execute `op(x)` under.
    (this is also explained in detail in the generalized evidence paper).

*/
module interface std/core/hnd
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/undiv = std/core/undiv = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
// Abstract type of Evidence vectors
type evv[136,1,136,14] <(e :: E)> :: E -> V ;
// The tag of a handler identifies the type at runtime (e.g. `"exn/core/std"`).
pub value{0,1,8} type htag[119,1,120,22] <(a :: (E, V) -> V)> :: ((E, V) -> V) -> V {
  con Htag[120,3,120,6](tagname: std/core/types/string){0,1,8} : forall<(a :: (E, V) -> V)> (tagname : std/core/types/string) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
};
// _Internal_. The type of handler markers (usually `:int32_t`).
// Needed for effect handlers in `module std/core/hnd`.
value{4,0,4} type marker[152,7,152,25] <(e :: E),a> :: (E, V) -> V ;
// Effect handler evidence of a handler `:h` in the context.
pub type ev[132,1,133,72] <(a :: (E, V) -> V)> :: ((E, V) -> V) -> V {
  con Ev[133,7,133,8]<(e :: E),b>(htag: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, marker: (marker :: (E, V) -> V)<(e :: E),b>, hnd: (a :: (E, V) -> V)<(e :: E),b>, hevv: (evv :: E -> V)<(e :: E)>){4,3,8} : forall<(a :: (E, V) -> V),(e :: E),b> (htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, marker : (marker :: (E, V) -> V)<(e :: E),b>, hnd : (a :: (E, V) -> V)<(e :: E),b>, hevv : (evv :: E -> V)<(e :: E)>) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
};
pub value{0,1,8} type clause0[703,1,704,48] <a,(b :: (E, V) -> V),(e :: E),c> :: (V, (E, V) -> V, E, V) -> V {
  con Clause0[704,3,704,9](clause: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a){0,1,8} : forall<a,(b :: (E, V) -> V),(e :: E),c> (clause : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
};
pub value{0,1,8} type clause1[607,1,608,51] <a,b,(c :: (E, V) -> V),(e :: E),d> :: (V, V, (E, V) -> V, E, V) -> V {
  con Clause1[608,3,608,9](clause: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b){0,1,8} : forall<a,b,(c :: (E, V) -> V),(e :: E),d> (clause : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
};
pub value{0,1,8} type clause2[749,1,750,56] <a,b,c,(d :: (E, V) -> V),(e :: E),a1> :: (V, V, V, (E, V) -> V, E, V) -> V {
  con Clause2[750,3,750,9](clause: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c){0,1,8} : forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> (clause : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
};
// Index into an evidence vector
pub alias ev-index[139,1,139,28] = std/core/types/ssize_t = 1;
value{0,2,8} type resume-result[380,7,383,24] <a,b> :: (V, V) -> V {
  con Deep[381,3,381,6](result: a){0,2,8} : forall<a,b> (result : a) -> (resume-result :: (V, V) -> V)<a,b>;
  con Shallow[382,3,382,9](result: a){0,2,8} : forall<a,b> (result : a) -> (resume-result :: (V, V) -> V)<a,b>;
  con Finalize[383,3,383,10](result: b){0,2,8} : forall<a,b> (result : b) -> (resume-result :: (V, V) -> V)<a,b>;
};
pub value{0,1,8} type resume-context[590,1,590,85] <a,(e :: E),(e1 :: E),b> :: (V, E, E, V) -> V {
  con Resume-context[590,23,590,36](k: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b){0,1,8} : forall<a,(e :: E),(e1 :: E),b> (k : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) -> (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>;
};
pub type yield-info[347,1,347,19] ;
value{0,3,8} type yld[385,7,389,80] <(e :: E),a,b> :: (E, V, V) -> V {
  con Pure[386,3,386,6]{0,1,8} : forall<(e :: E),a,b> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
  con YieldingFinal[387,3,387,15]{0,1,8} : forall<(e :: E),a,b> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
  con Yielding[388,3,388,10]{0,1,8} : forall<(e :: E),a,b> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
  con Yield[389,3,389,7]<c>(clause: (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b, cont: (() -> c) -> (e :: E) a){0,3,8} : forall<(e :: E),a,b,c> (clause : (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b, cont : (() -> c) -> (e :: E) a) -> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `tagname` constructor field of the `:htag` type.
 fun htag/tagname[120,8,120,14] : forall<(a :: (E, V) -> V)> (^ htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> std/core/types/string;
pub  fun htag/@copy[120,3,120,6] : forall<(a :: (E, V) -> V)> (@this : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, tagname : (std/core/types/@optional :: V -> V)<std/core/types/string>) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
// Automatically generated. Retrieves the `htag` constructor field of the `:ev` type.
 fun ev/htag[133,15,133,18] : forall<(a :: (E, V) -> V)> (^ ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
pub  fun ev/@copy[133,7,133,8] : forall<(a :: (E, V) -> V),(e :: E),b> (@this : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, htag : (std/core/types/@optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>, marker : (marker :: (E, V) -> V)<(e :: E),b>, hnd : (a :: (E, V) -> V)<(e :: E),b>, hevv : (evv :: E -> V)<(e :: E)>) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
// Automatically generated. Retrieves the `clause` constructor field of the `:clause0` type.
 fun clause0/clause[704,12,704,17] : forall<a,(b :: (E, V) -> V),(e :: E),c> (^ clause0 : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>) -> (((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a);
pub  fun clause0/@copy[704,3,704,9] : forall<a,(b :: (E, V) -> V),(e :: E),c> (@this : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>, clause : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
// Automatically generated. Retrieves the `clause` constructor field of the `:clause1` type.
 fun clause1/clause[608,12,608,17] : forall<a,b,(c :: (E, V) -> V),(e :: E),d> (^ clause1 : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>) -> (((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b);
pub  fun clause1/@copy[608,3,608,9] : forall<a,b,(c :: (E, V) -> V),(e :: E),d> (@this : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>, clause : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
// Automatically generated. Retrieves the `clause` constructor field of the `:clause2` type.
 fun clause2/clause[750,12,750,17] : forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> (^ clause2 : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>) -> (((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c);
pub  fun clause2/@copy[750,3,750,9] : forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> (@this : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>, clause : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
// Automatically generated. Tests for the `Deep` constructor of the `:resume-result` type.
fip fun is-deep[381,3,381,6] : forall<a,b> (^ resume-result : (resume-result :: (V, V) -> V)<a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Shallow` constructor of the `:resume-result` type.
fip fun is-shallow[382,3,382,9] : forall<a,b> (^ resume-result : (resume-result :: (V, V) -> V)<a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Finalize` constructor of the `:resume-result` type.
fip fun is-finalize[383,3,383,10] : forall<a,b> (^ resume-result : (resume-result :: (V, V) -> V)<a,b>) -> std/core/types/bool;
// Automatically generated. Retrieves the `k` constructor field of the `:resume-context` type.
 fun resume-context/k[590,55,590,55] : forall<a,(e :: E),(e1 :: E),b> (^ @this : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b);
pub  fun resume-context/@copy[590,23,590,36] : forall<a,(e :: E),(e1 :: E),b> (@this : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, k : (std/core/types/@optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>) -> (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>;
// Automatically generated. Tests for the `Pure` constructor of the `:yld` type.
fip fun is-pure[386,3,386,6] : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `YieldingFinal` constructor of the `:yld` type.
fip fun is-yieldingFinal[387,3,387,15] : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Yielding` constructor of the `:yld` type.
fip fun is-yielding[388,3,388,10] : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Yield` constructor of the `:yld` type.
fip fun is-yield[389,3,389,7] : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// (dynamically) find evidence insertion/deletion index in the evidence vector
// The compiler optimizes `@evv-index` to a static index when apparent from the effect type.
pub  fun @evv-index[207,12,207,21] : forall<(e :: E),(a :: (E, V) -> V)> (htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (e :: E) ev-index;
// Does the current evidence vector consist solely of affine handlers?
// This is called in backends that do not have context paths (like javascript)
// to optimize TRMC (where we can use faster update-in-place TRMC if we know the
// operations are all affine). As such, it is always safe to return `false`.
//
// control flow context:
//                 -1: none: bottom
//                   /          \
// 0: except: never resumes   1: linear: resumes exactly once
//                   \          /
//           2: affine: resumes never or once
//                        |
//     3: multi: resumes never, once, or multiple times
//
pub  fun @evv-is-affine[238,12,238,25] : () -> std/core/types/bool;
 fun @reset-vm[445,8,445,16] : forall<a,(e :: E),b> (m : (marker :: (E, V) -> V)<(e :: E),b>, ret : (a) -> (e :: E) b, action : () -> (e :: E) a) -> (e :: E) b;
// mask for builtin effects without a handler or evidence (like `:st` or `:local`)
pub  fun @mask-builtin[493,9,493,21] : forall<a,(e :: E),(e1 :: E)> (action : () -> (e :: E) a) -> (e1 :: E) a;
// _Internal_ hidden constructor for creating handler tags
pub  fun @new-htag[123,9,123,17] : forall<(a :: (E, V) -> V)> (tag : std/core/types/string) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
pub  fun @open-none0[855,9,855,19] : forall<a,(e :: E),(e1 :: E)> (f : () -> (e :: E) a) -> (e1 :: E) a;
pub  fun @open-none1[861,9,861,19] : forall<a,b,(e :: E),(e1 :: E)> (f : (a) -> (e :: E) b, x1 : a) -> (e1 :: E) b;
pub  fun @open-none2[867,9,867,19] : forall<a,b,c,(e :: E),(e1 :: E)> (f : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e1 :: E) c;
pub  fun @open-none3[873,9,873,19] : forall<a,b,c,d,(e :: E),(e1 :: E)> (f : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e1 :: E) d;
pub  fun @open-none4[879,9,879,19] : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (f : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e1 :: E) a1;
//inline extern cast-hnd( h : h<e1,r> ) : e h<e,r> { inline "#1"//inline extern cast-marker( m : marker<e1,r> ) : e marker<e,r> { inline "#1"
pub  fun @perform0[708,16,708,24] : forall<a,(e :: E),(b :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op : forall<(e1 :: E),c> ((b :: (E, V) -> V)<(e1 :: E),c>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>) -> (e :: E) a;
pub  fun @perform1[621,16,621,24] : forall<a,b,(c :: (E, V) -> V),(e :: E)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x : a) -> (e :: E) b;
pub  fun @perform2[781,16,781,24] : forall<a,b,c,(e :: E),(d :: (E, V) -> V)> (evx : (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, op : forall<(e1 :: E),a1> ((d :: (E, V) -> V)<(e1 :: E),a1>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>, x : a, y : b) -> (e :: E) c;
 fun @prompt-local-var-prim-vm[512,8,512,32] : forall<a,b,(e :: E),(h :: H)> (init : a, action : (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b;
 fun @protect-vm[671,14,671,24] : forall<a,b,(e :: E),c> (x : a, clause : (x : a, k : (b) -> (e :: E) c) -> (e :: E) c, k : (b) -> (e :: E) c) -> (e :: E) c;
 fun @yield-to-prim-vm[325,8,325,24] : forall<a,(e :: E),(e1 :: E),b> (m : (marker :: (E, V) -> V)<(e1 :: E),b>, clause : ((a) -> (e1 :: E) b) -> (e1 :: E) b) -> (e :: E) a;
// Get the current evidence vector.
 fun evv-get[213,8,213,14] : forall<(e :: E)> () -> (e :: E) (evv :: E -> V)<(e :: E)>;
// Insert new evidence into the given evidence vector.
 fun evv-insert[177,8,177,17] : forall<(e :: E),(e1 :: E),(a :: (E, V) -> V)> (evv : (evv :: E -> V)<(e :: E)>, ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(e1 :: E)>;
 fun fresh-marker[158,8,158,19] : forall<a,(e :: E)> () -> (marker :: (E, V) -> V)<(e :: E),a>;
// Is an evidence vector unchanged? (i.e. as pointer equality).
// This is used to avoid copying in common cases.
 fun evv-eq[189,8,189,13] : forall<(e :: E)> (evv0 : (evv :: E -> V)<(e :: E)>, evv1 : (evv :: E -> V)<(e :: E)>) -> std/core/types/bool;
 fun guard[391,8,391,12] : forall<(e :: E)> (w : (evv :: E -> V)<(e :: E)>) -> (e :: E) ();
pub  fun yield-extend[298,21,298,32] : forall<a,b,(e :: E)> (next : (a) -> (e :: E) b) -> (e :: E) b;
 fun yield-cont[308,8,308,17] : forall<a,(e :: E),b> (f : forall<c> ((c) -> (e :: E) a, c) -> (e :: E) b) -> (e :: E) b;
 fun yield-prompt[316,8,316,19] : forall<a,(e :: E),b> (m : (marker :: (E, V) -> V)<(e :: E),b>) -> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
 fun yield-to-final[330,8,330,21] : forall<a,(e :: E),(e1 :: E),b> (m : (marker :: (E, V) -> V)<(e1 :: E),b>, clause : (((resume-result :: (V, V) -> V)<a,b>) -> (e1 :: E) b) -> (e1 :: E) b) -> (e :: E) a;
// Remove evidence at index `i` of the current evidence vector, and return the old one.
// (used by `mask`)
 fun evv-swap-delete[257,8,257,22] : forall<(e :: E),(e1 :: E)> (i : ev-index, behind : std/core/types/bool) -> (e1 :: E) (evv :: E -> V)<(e :: E)>;
 fun fresh-marker-named[163,8,163,25] : forall<a,(e :: E)> () -> (marker :: (E, V) -> V)<(e :: E),a>;
// Swap the current evidence vector with a new vector consisting of evidence
// at indices `indices` in the current vector.
 fun evv-swap-create[278,8,278,22] : forall<(e :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>) -> (e :: E) (evv :: E -> V)<(e :: E)>;
// For interal use
 fun xperform1[796,5,796,13] : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x : a) -> (e :: E) b;
 fun yield-to-prim[321,17,321,29] : forall<a,(e :: E),(e1 :: E),b> (m : (marker :: (E, V) -> V)<(e1 :: E),b>, clause : (((resume-result :: (V, V) -> V)<a,b>) -> (e1 :: E) b) -> (e1 :: E) b) -> (e :: E) (() -> a);
pub  fun clause-tail-noop0[736,9,736,25] : forall<(e :: E),a,(b :: (E, V) -> V),c> (op : () -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(b :: (E, V) -> V),(e :: E),a>;
// tail-resumptive clause that does not itself invoke operations
// (these can be executed 'in-place' without setting the correct evidence vector)
pub  fun clause-tail-noop1[690,9,690,25] : forall<(e :: E),a,(b :: (E, V) -> V),c,d> (op : (c) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<c,d,(b :: (E, V) -> V),(e :: E),a>;
pub  fun clause-tail-noop2[778,9,778,25] : forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1> (op : (c, d) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,d,a1,(b :: (E, V) -> V),(e :: E),a>;
 fun evv-swap-with[626,5,626,17] : forall<(a :: (E, V) -> V),(e :: E)> (ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (evv :: E -> V)<(e :: E)>;
pub  fun clause-value[739,9,739,20] : forall<a,(e :: E),(b :: (E, V) -> V),c> (v : a) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
// Are two markers equal?
 fun eq-marker[155,8,155,16] : forall<a,b,(e :: E),(e1 :: E)> (x : (marker :: (E, V) -> V)<(e :: E),a>, y : (marker :: (E, V) -> V)<(e1 :: E),b>) -> std/core/types/bool;
// show evidence for debug purposes
 fun evv-show[183,8,183,15] : forall<(e :: E)> (evv : (evv :: E -> V)<(e :: E)>) -> std/core/types/string;
pub  fun unsafe-reyield[353,12,353,25] : forall<a,(e :: E)> (yld : yield-info) -> (e :: E) a;
 fun yield-capture[349,8,349,20] : forall<(e :: E)> () -> (e :: E) yield-info;
 fun get[650,5,650,7] : forall<a,(h :: H)> (ref : (std/core/types/ref :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/div :: X)> a;
pub  fun resume[592,9,592,14] : forall<a,(e :: E),(e1 :: E),b> (r : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x : a) -> (e :: E) b;
 fun resume-final[395,8,395,19] : forall<a> () -> a;
pub  fun resume-shallow[595,9,595,22] : forall<a,(e :: E),(e1 :: E),b> (r : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x : a) -> (e1 :: E) b;
// Show a handler tag.
pub  fun htag/show[127,9,127,17] : forall<(a :: (E, V) -> V)> (@pat-x127_20 : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> std/core/types/string;
pub  fun yield-bind[302,16,302,25] : forall<a,b,(e :: E)> (x : a, next : (a) -> (e :: E) b) -> (e :: E) b;
 fun prompt[399,5,399,10] : forall<a,(e :: E),(b :: (E, V) -> V),c> (w0 : (evv :: E -> V)<(e :: E)>, w1 : (evv :: E -> V)<(e :: E)>, ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, m : (marker :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, result : a) -> (e :: E) c;
pub  fun @hhandle[435,18,435,25] : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (tag : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, h : (b :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, action : () -> (e1 :: E) a) -> (e :: E) c;
pub  fun @hhandle-vm[450,18,450,28] : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (tag : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, h : (b :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, action : () -> (e1 :: E) a) -> (e :: E) c;
 fun mask-at1[478,5,478,12] : forall<a,b,(e :: E),(e1 :: E)> (i : ev-index, behind : std/core/types/bool, action : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub  fun @mask-at[485,9,485,16] : forall<a,(e :: E),(e1 :: E)> (i : ev-index, behind : std/core/types/bool, action : () -> (e :: E) a) -> (e1 :: E) a;
pub  fun @named-handle[466,18,466,30] : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (tag : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, h : (b :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, action : ((ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) -> (e :: E) c;
 fun open-at1[886,14,886,21] : forall<a,b,(e :: E),(e1 :: E)> (i : ev-index, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub  fun @open-at0[893,9,893,17] : forall<a,(e :: E),(e1 :: E)> (i : ev-index, f : () -> (e :: E) a) -> (e1 :: E) a;
pub  fun @open-at1[900,9,900,17] : forall<a,b,(e :: E),(e1 :: E)> (i : ev-index, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub  fun @open-at2[907,9,907,17] : forall<a,b,c,(e :: E),(e1 :: E)> (i : ev-index, f : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e1 :: E) c;
pub  fun @open-at3[914,9,914,17] : forall<a,b,c,d,(e :: E),(e1 :: E)> (i : ev-index, f : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e1 :: E) d;
pub  fun @open-at4[921,9,921,17] : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (i : ev-index, f : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e1 :: E) a1;
 fun open1[929,14,929,18] : forall<a,b,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub  fun @open0[937,9,937,14] : forall<a,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : () -> (e :: E) a) -> (e1 :: E) a;
pub  fun @open1[944,9,944,14] : forall<a,b,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub  fun @open2[951,9,951,14] : forall<a,b,c,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e1 :: E) c;
pub  fun @open3[958,9,958,14] : forall<a,b,c,d,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e1 :: E) d;
pub  fun @open4[965,9,965,14] : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e1 :: E) a1;
pub  fun @perform3[816,9,816,17] : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, op : forall<(e1 :: E),b1> ((a1 :: (E, V) -> V)<(e1 :: E),b1>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e1 :: E),b1>, x1 : a, x2 : b, x3 : c) -> (e :: E) d;
pub  fun @perform4[840,9,840,17] : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b1 :: (E, V) -> V)>, op : forall<(e1 :: E),c1> ((b1 :: (E, V) -> V)<(e1 :: E),c1>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e1 :: E),c1>, x1 : a, x2 : b, x3 : c, x4 : d) -> (e :: E) a1;
 fun @yield-to-vm[341,14,341,25] : forall<a,(e :: E),b> (m : (marker :: (E, V) -> V)<(e :: E),b>, clause : ((a) -> (e :: E) b) -> (e :: E) b) -> (e :: E) a;
 fun yield-to[334,14,334,21] : forall<a,(e :: E),b> (m : (marker :: (E, V) -> V)<(e :: E),b>, clause : (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) -> (e :: E) b) -> (e :: E) a;
pub  fun clause-control-raw0[721,9,721,27] : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (op : ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),c>) -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
pub  fun clause-control-raw1[647,9,647,27] : forall<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d> (op : (x : a, r : (resume-context :: (V, E, E, V) -> V)<b,(e :: E),(e1 :: E),d>) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
pub  fun clause-control-raw2[772,9,772,27] : forall<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1> (op : (x1 : a, x2 : b, r : (resume-context :: (V, E, E, V) -> V)<c,(e :: E),(e1 :: E),a1>) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
pub  fun clause-control-raw3[801,9,801,27] : forall<a,b,c,d,(e :: E),(e1 :: E),(a1 :: (E, V) -> V),b1> (op : (x1 : a, x2 : b, x3 : c, r : (resume-context :: (V, E, E, V) -> V)<d,(e :: E),(e1 :: E),b1>) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub  fun finalize[599,9,599,16] : forall<a,(e :: E),(e1 :: E),b> (r : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x : b) -> (e :: E) b;
 fun protect-check[656,5,656,17] : forall<a,(e :: E),b> (resumed : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/bool>, k : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b, res : b) -> (e :: E) b;
 fun protect[662,14,662,20] : forall<a,b,(e :: E),c> (x : a, clause : (x : a, k : (b) -> (e :: E) c) -> (e :: E) c, k : ((resume-result :: (V, V) -> V)<b,c>) -> (e :: E) c) -> (e :: E) c;
pub  fun clause-control0[729,9,729,23] : forall<a,(e :: E),(b :: (E, V) -> V),c> (op : ((a) -> (e :: E) c) -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
// generic control clause
pub  fun clause-control1[680,9,680,23] : forall<a,b,(e :: E),(c :: (E, V) -> V),d> (clause : (x : a, k : (b) -> (e :: E) d) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
 fun protect2[759,5,759,12] : forall<a,b,c,(e :: E),d> (x1 : a, x2 : b, clause : (x : a, x : b, k : (c) -> (e :: E) d) -> (e :: E) d, k : ((resume-result :: (V, V) -> V)<c,d>) -> (e :: E) d) -> (e :: E) d;
pub  fun clause-control2[768,9,768,23] : forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> (clause : (x1 : a, x2 : b, k : (c) -> (e :: E) a1) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
pub  fun clause-control3[804,9,804,23] : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> (op : (x1 : a, x2 : b, x3 : c, k : (d) -> (e :: E) b1) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub  fun clause-control4[828,9,828,23] : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> (op : (x1 : a, x2 : b, x3 : c, x4 : d, k : (a1) -> (e :: E) c1) -> (e :: E) c1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>;
pub  fun clause-never0[742,9,742,21] : forall<a,(e :: E),(b :: (E, V) -> V),c> (op : () -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
// clause that never resumes (e.g. an exception handler)
// (these do not need to capture a resumption and execute finally clauses upfront)
pub  fun clause-never1[695,9,695,21] : forall<a,b,(e :: E),(c :: (E, V) -> V),d> (op : (a) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
pub  fun clause-never2[786,9,786,21] : forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> (op : (a, b) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
pub  fun clause-never3[813,9,813,21] : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> (op : (a, b, c) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub  fun clause-never4[837,9,837,21] : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> (op : (a, b, c, d) -> (e :: E) c1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>;
pub  fun clause-tail-noop3[810,9,810,25] : forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1> (op : (c, d, a1) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(c, d, a1),b1,(b :: (E, V) -> V),(e :: E),a>;
pub  fun clause-tail-noop4[834,9,834,25] : forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1,c1> (op : (c, d, a1, b1) -> (e :: E) c1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(c, d, a1, b1),c1,(b :: (E, V) -> V),(e :: E),a>;
// extra under1x to make under1 inlineable
 fun under1x[639,14,639,20] : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : (a) -> (e :: E) b, x : a) -> (e :: E) b;
 fun under1[630,12,630,17] : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : (a) -> (e :: E) b, x : a) -> (e :: E) b;
 fun under0[713,12,713,17] : forall<a,(e :: E),(b :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op : () -> (e :: E) a) -> (e :: E) a;
pub  fun clause-tail0[733,9,733,20] : forall<(e :: E),a,(b :: (E, V) -> V),c> (op : () -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(b :: (E, V) -> V),(e :: E),a>;
// tail-resumptive clause: resumes exactly once at the end
// (these can be executed 'in-place' without capturing a resumption)
pub  fun clause-tail1[685,9,685,20] : forall<(e :: E),a,(b :: (E, V) -> V),c,d> (op : (c) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<c,d,(b :: (E, V) -> V),(e :: E),a>;
 fun under2[752,5,752,10] : forall<a,b,c,(e :: E),(d :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, op : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e :: E) c;
pub  fun clause-tail2[775,9,775,20] : forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1> (op : (c, d) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,d,a1,(b :: (E, V) -> V),(e :: E),a>;
pub  fun clause-tail3[807,9,807,20] : forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1> (op : (c, d, a1) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(c, d, a1),b1,(b :: (E, V) -> V),(e :: E),a>;
pub  fun clause-tail4[831,9,831,20] : forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1,c1> (op : (c, d, a1, b1) -> (e :: E) c1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(c, d, a1, b1),c1,(b :: (E, V) -> V),(e :: E),a>;
 fun finally-prompt[528,5,528,18] : forall<a,(e :: E)> (fin : () -> (e :: E) (), res : a) -> (e :: E) a;
pub  fun finally[525,9,525,15] : forall<a,(e :: E)> (fin : () -> (e :: E) (), action : () -> (e :: E) a) -> (e :: E) a;
 fun initially-prompt[571,5,571,20] : forall<a,(e :: E)> (init : (std/core/types/int) -> (e :: E) (), res : a) -> (e :: E) a;
pub  fun initially[566,9,566,17] : forall<a,(e :: E)> (init : (std/core/types/int) -> (e :: E) (), action : () -> (e :: E) a) -> (e :: E) a;
 fun prompt-local-var[501,5,501,20] : forall<a,b,(h :: H)> (loc : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>, res : b) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>> b;
pub  fun local-var[506,16,506,24] : forall<a,b,(e :: E),(h :: H)> (init : a, action : (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b;
pub  fun local-var-vm[517,9,517,20] : forall<a,b,(e :: E),(h :: H)> (init : a, action : (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b;
 fun try-finalize-prompt[979,5,979,23] : forall<a,(e :: E)> (res : a) -> (e :: E) (std/core/types/either :: (V, V) -> V)<yield-info,a>;
 fun under3[819,5,819,10] : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, op : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e :: E) d;
 fun under4[843,5,843,10] : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b1 :: (E, V) -> V)>, op : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e :: E) a1;
pub  fun unsafe-try-finalize[976,9,976,27] : forall<a,(e :: E)> (action : () -> (e :: E) a) -> (e :: E) (std/core/types/either :: (V, V) -> V)<yield-info,a>;
pub  fun yield-bind2[305,16,305,26] : forall<a,b,(e :: E)> (x : a, extend : (a) -> (e :: E) b, next : (a) -> (e :: E) b) -> (e :: E) b;
// Evidence equality compares the markers.
pub  fun ev/(==)[142,9,142,15] : forall<(a :: (E, V) -> V)> (@pat-x142_18 : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, @pat-x142_37 : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> std/core/types/bool;
 
//------------------------------
//#kki: external declarations
 
// Return the evidence at index `i` in the current evidence vector.
pub  extern @evv-at[200,19,200,25] : forall<(a :: (E, V) -> V)> (i : ev-index) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> {
  c inline "kk_evv_at(#1,kk_context())";
  js inline "$std_core_hnd._evv_at(#1)";
  vm inline "!sexp:((qualified $\x22import$std/core/hnd\x22:ptr \x22elt\x22 (fun Pure (ptr int) ptr)) (\x22promote_ptr\x22 ((qualified $\x22import$std/core/hnd\x22:ptr \x22getCurrentEvv\x22 (fun Effectful () ptr)))) $arg0:int)";
};
// Set the current evidence vector.
 extern evv-set[219,15,219,21] : forall<(e :: E),(e1 :: E)> (w : (evv :: E -> V)<(e1 :: E)>) -> (e :: E) () {
  c inline "kk_evv_set(#1,kk_context())";
  js inline "$std_core_hnd._evv_set(#1)";
  vm inline "!sexp:((qualified $\x22import$std/core/hnd\x22:ptr \x22setCurrentEvv\x22 (fun Effectful (ptr) unit)) $arg0:ptr)";
};
// Swap the current evidence vector with `w`
 extern evv-swap[250,15,250,22] : forall<(e :: E),(e1 :: E),(e2 :: E)> (w : (evv :: E -> V)<(e1 :: E)>) -> (e :: E) (evv :: E -> V)<(e2 :: E)> {
  c inline "kk_evv_swap(#1,kk_context())";
  js inline "$std_core_hnd._evv_swap(#1)";
  vm inline "!sexp:((qualified $\x22import$std/core/hnd\x22:ptr \x22swapCurrentEvv\x22 (fun Effectful (ptr) ptr)) $arg0:ptr)";
};
// Swap the current evidence vector with an empty vector.
// (this is used in open calls to switch to a total context)
 extern evv-swap-create0[264,15,264,30] : forall<(e :: E)> () -> (e :: E) (evv :: E -> V)<(e :: E)> {
  c inline "kk_evv_swap_create0(kk_context())";
  js inline "$std_core_hnd._evv_swap_create0()";
  vm inline "!sexp:((qualified $\x22import$std/core/hnd\x22:ptr \x22evvSwapCreate0\x22 (fun Effectful () ptr)))";
};
// Swap the current evidence vector with a singleton vector (with the evidence at current index `i`).
// (this is common in open calls to switch to a singleton effect context when calling operations)
 extern evv-swap-create1[271,15,271,30] : forall<(e :: E)> (i : ev-index) -> (e :: E) (evv :: E -> V)<(e :: E)> {
  c inline "kk_evv_swap_create1(#1,kk_context())";
  js inline "$std_core_hnd._evv_swap_create1(#1)";
  vm inline "!sexp:((qualified $\x22import$std/core/hnd\x22:ptr \x22evvSwapCreate1\x22 (fun Effectful (int) ptr)) $arg0:ptr)";
};
pub  extern yielding[288,19,288,26] : () -> std/core/types/bool {
  c inline "kk_yielding(kk_context())";
  js inline "$std_core_hnd._yielding()";
  vm inline "!sexp:0";
};
pub  extern yielding-non-final[293,19,293,36] : () -> std/core/types/bool {
  c inline "kk_yielding_non_final(kk_context())";
  js inline "$std_core_hnd._yielding_non_final()";
  vm inline "!sexp:0";
};
 extern keep-yielding-final[312,15,312,33] : forall<(e :: E),a> () -> (e :: E) a {
  c inline "kk_box_any(kk_context())";
  js inline "undefined";
};
 extern cast-ev0[362,15,362,22] : forall<a,(e :: E),(e1 :: E)> (f : () -> (e1 :: E) a) -> (() -> (e :: E) a) = inline "#1";
 extern cast-ev1[365,15,365,22] : forall<a,b,(e :: E),(e1 :: E)> (f : (a) -> (e1 :: E) b) -> ((a) -> (e :: E) b) = inline "#1";
 extern cast-ev2[368,15,368,22] : forall<a,b,c,(e :: E),(e1 :: E)> (f : (a, b) -> (e1 :: E) c) -> ((a, b) -> (e :: E) c) = inline "#1";
 extern cast-ev3[371,15,371,22] : forall<a,b,c,d,(e :: E),(e1 :: E)> (f : (a, b, c) -> (e1 :: E) d) -> ((a, b, c) -> (e :: E) d) = inline "#1";
 extern cast-ev4[374,15,374,22] : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (f : (a, b, c, d) -> (e1 :: E) a1) -> ((a, b, c, d) -> (e :: E) a1) = inline "#1";
 extern cast-ev5[377,15,377,22] : forall<a,b,c,d,a1,b1,(e :: E),(e1 :: E)> (f : (a, b, c, d, a1) -> (e1 :: E) b1) -> ((a, b, c, d, a1) -> (e :: E) b1) = inline "#1";
// add integers
 extern add[552,15,552,17] : (i : std/core/types/int, j : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_add(#1,#2,kk_context())";
  cs inline "(#1 + #2)";
  js inline "(#1 + #2)";
  vm inline "infixAdd(Int, Int): Int";
};
// are two integers equal?
 extern eq[559,15,559,16] : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_eq_borrow(#1,#2,kk_context())";
  cs inline "(#1 == #2)";
  js inline "(#1 == #2)";
  vm inline "infixEq(Int, Int): Int";
};
 extern cast-clause0[610,15,610,26] : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (f : ((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) -> (e :: E) (((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) {
  inline "#1";
  vm inline "!sexp:(debugWrap \x22cast-clause0\x22 $arg0:top)";
};
 extern cast-clause1[614,15,614,26] : forall<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d> (f : ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) -> (e :: E) (((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) = inline "#1";
 extern cast-clause2[617,15,617,26] : forall<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1> (f : ((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e1 :: E) c) -> (e :: E) (((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) = inline "#1";
 extern unsafe-st[653,15,653,23] : forall<a,(e :: E)> (f : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>|(e :: E)> a) -> (() -> (e :: E) a) = inline "#1";
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun htag/tagname // inline size: 0
  = forall<(a :: (E, V) -> V)> fn(htag: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (htag) {
      ((@skip std/core/hnd/Htag((@x: std/core/types/string) : std/core/types/string) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat: ((htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> @x;
    });
  };
 fun htag/@copy // inline size: 2
  = forall<(a :: (E, V) -> V)> fn(@this: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, tagname: (std/core/types/@optional :: V -> V)<std/core/types/string>){
    std/core/hnd/Htag<(a :: (E, V) -> V)>((match (tagname) {
      ((std/core/types/@Optional((@uniq-tagname@2014: std/core/types/string) : std/core/types/string) : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
         -> @uniq-tagname@2014;
      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
         -> (match (@this) {
          ((@skip std/core/hnd/Htag((@x: std/core/types/string) : std/core/types/string) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat@1: ((htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
             -> @x;
        });
    }));
  };
inline borrow "^"  fun ev/htag // inline size: 0
  = forall<(a :: (E, V) -> V)> fn(ev: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (ev) {
      ((@skip std/core/hnd/Ev<(e :: E),b>((@x: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (@pat@0: (marker :: (E, V) -> V)<(e :: E),b>) : (marker :: (E, V) -> V)<(e :: E),b>, (@pat@1: (a :: (E, V) -> V)<(e :: E),b>) : (a :: (E, V) -> V)<(e :: E),b>, (@pat@2: (evv :: E -> V)<(e :: E)>) : (evv :: E -> V)<(e :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> @x;
    });
  };
 fun ev/@copy // inline size: 2
  = forall<(a :: (E, V) -> V),(e :: E),b> fn(@this: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, htag: (std/core/types/@optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>, marker: (marker :: (E, V) -> V)<(e :: E),b>, hnd: (a :: (E, V) -> V)<(e :: E),b>, hevv: (evv :: E -> V)<(e :: E)>){
    std/core/hnd/Ev<(a :: (E, V) -> V),(e :: E),b>((match (htag) {
        ((std/core/types/@Optional((@uniq-htag@2065: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (std/core/types/@optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>> ) as @pat: ((std/core/types/@optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>))
           -> @uniq-htag@2065;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>> ) as @pat@0: ((std/core/types/@optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>))
           -> (match (@this) {
            ((@skip std/core/hnd/Ev<(e1 :: E),c>((@x: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (@pat@0@0: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (@pat@1@0: (a :: (E, V) -> V)<(e1 :: E),c>) : (a :: (E, V) -> V)<(e1 :: E),c>, (@pat@2: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat@1: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
               -> @x;
          });
      }), marker, hnd, hevv);
  };
inline borrow "^"  fun clause0/clause // inline size: 0
  = forall<a,(b :: (E, V) -> V),(e :: E),c> fn(clause0: (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>){
    (match (clause0) {
      ((@skip std/core/hnd/Clause0((@x: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c> ) as @pat: ((clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>))
         -> @x;
    });
  };
 fun clause0/@copy // inline size: 2
  = forall<a,(b :: (E, V) -> V),(e :: E),c> fn(@this: (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>, clause: (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((match (clause) {
      ((std/core/types/@Optional((@uniq-clause@2165: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a> ) as @pat: ((std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>))
         -> @uniq-clause@2165;
      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a> ) as @pat@0: ((std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>))
         -> (match (@this) {
          ((@skip std/core/hnd/Clause0((@x: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c> ) as @pat@1: ((clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>))
             -> @x;
        });
    }));
  };
inline borrow "^"  fun clause1/clause // inline size: 0
  = forall<a,b,(c :: (E, V) -> V),(e :: E),d> fn(clause1: (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>){
    (match (clause1) {
      ((@skip std/core/hnd/Clause1((@x: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d> ) as @pat: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>))
         -> @x;
    });
  };
 fun clause1/@copy // inline size: 2
  = forall<a,b,(c :: (E, V) -> V),(e :: E),d> fn(@this: (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>, clause: (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((match (clause) {
      ((std/core/types/@Optional((@uniq-clause@2287: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b> ) as @pat: ((std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>))
         -> @uniq-clause@2287;
      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b> ) as @pat@0: ((std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>))
         -> (match (@this) {
          ((@skip std/core/hnd/Clause1((@x: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d> ) as @pat@1: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>))
             -> @x;
        });
    }));
  };
inline borrow "^"  fun clause2/clause // inline size: 0
  = forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> fn(clause2: (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>){
    (match (clause2) {
      ((@skip std/core/hnd/Clause2((@x: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1> ) as @pat: ((clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>))
         -> @x;
    });
  };
 fun clause2/@copy // inline size: 2
  = forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> fn(@this: (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>, clause: (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((match (clause) {
      ((std/core/types/@Optional((@uniq-clause@2435: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c> ) as @pat: ((std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>))
         -> @uniq-clause@2435;
      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c> ) as @pat@0: ((std/core/types/@optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>))
         -> (match (@this) {
          ((@skip std/core/hnd/Clause2((@x: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1> ) as @pat@1: ((clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>))
             -> @x;
        });
    }));
  };
inline borrow "^" fip fun is-deep // inline size: 1
  = forall<a,b> fn(resume-result: (resume-result :: (V, V) -> V)<a,b>){
    (match (resume-result) {
      ((std/core/hnd/Deep((@pat@0: a) : a) : (resume-result :: (V, V) -> V)<a,b> ) as @pat: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/True;
      (@pat@1: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fip fun is-shallow // inline size: 1
  = forall<a,b> fn(resume-result: (resume-result :: (V, V) -> V)<a,b>){
    (match (resume-result) {
      ((std/core/hnd/Shallow((@pat@0: a) : a) : (resume-result :: (V, V) -> V)<a,b> ) as @pat: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/True;
      (@pat@1: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fip fun is-finalize // inline size: 1
  = forall<a,b> fn(resume-result: (resume-result :: (V, V) -> V)<a,b>){
    (match (resume-result) {
      ((std/core/hnd/Finalize((@pat@0: b) : b) : (resume-result :: (V, V) -> V)<a,b> ) as @pat: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/True;
      (@pat@1: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^"  fun resume-context/k // inline size: 0
  = forall<a,(e :: E),(e1 :: E),b> fn(@this: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>){
    (match (@this) {
      ((@skip std/core/hnd/Resume-context((@x: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b> ) as @pat: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>))
         -> @x;
    });
  };
 fun resume-context/@copy // inline size: 2
  = forall<a,(e :: E),(e1 :: E),b> fn(@this: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, k: (std/core/types/@optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>){
    std/core/hnd/Resume-context<a,(e :: E),(e1 :: E),b>((match (k) {
      ((std/core/types/@Optional((@uniq-k@2619: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (std/core/types/@optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b> ) as @pat: ((std/core/types/@optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>))
         -> @uniq-k@2619;
      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b> ) as @pat@0: ((std/core/types/@optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>))
         -> (match (@this) {
          ((@skip std/core/hnd/Resume-context((@x: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b> ) as @pat@1: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>))
             -> @x;
        });
    }));
  };
inline borrow "^" fip fun is-pure // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/Pure() : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as @pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (@pat@0: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fip fun is-yieldingFinal // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/YieldingFinal() : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as @pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (@pat@0: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fip fun is-yielding // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/Yielding() : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as @pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (@pat@0: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fip fun is-yield // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/Yield<c>((@pat@0: (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b) : (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b, (@pat@1: (() -> c) -> (e :: E) a) : (() -> c) -> (e :: E) a) : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as @pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (@pat@2: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
 fun @mask-builtin // inline size: 3
  = forall<a,(e :: E),(e1 :: E)> fn<(e1 :: E)>(action: () -> (e :: E) a){
    std/core/types/@open<(std/core/types/total :: E),(e1 :: E),(f : () -> (e :: E) a) -> (() -> (e1 :: E) a),(f : () -> (e :: E) a) -> (e1 :: E) (() -> (e1 :: E) a)>((std/core/hnd/cast-ev0<a,(e1 :: E),(e :: E)>))(action)();
  };
 fun @new-htag // inline size: 1
  = forall<(a :: (E, V) -> V)> fn(tag: std/core/types/string){
    std/core/hnd/Htag<(a :: (E, V) -> V)>(tag);
  };
inline  fun @perform0 // inline size: 4
  = forall<a,(e :: E),(b :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op: forall<(e1 :: E),c> ((b :: (E, V) -> V)<(e1 :: E),c>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>){
    (match (ev) {
      ((@skip std/core/hnd/Ev<(e1 :: E),c>((@pat@0: (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, (m: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (h: (b :: (E, V) -> V)<(e1 :: E),c>) : (b :: (E, V) -> V)<(e1 :: E),c>, (@pat@1: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>))
         -> (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),((b :: (E, V) -> V)<(e1 :: E),c>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>,((b :: (E, V) -> V)<(e1 :: E),c>) -> (e :: E) (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>>((op<(e1 :: E),c>))(h))) {
          ((@skip std/core/hnd/Clause0((f: ((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) : ((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c> ) as @pat@2: ((clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>))
             -> std/core/hnd/cast-clause0<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c>(f)(m, ev);
        });
    });
  };
inline  fun @perform1 // inline size: 4
  = forall<a,b,(c :: (E, V) -> V),(e :: E)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op: forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x: a){
    (match (ev) {
      ((@skip std/core/hnd/Ev<(e1 :: E),d>((@pat@0: (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, (m: (marker :: (E, V) -> V)<(e1 :: E),d>) : (marker :: (E, V) -> V)<(e1 :: E),d>, (h: (c :: (E, V) -> V)<(e1 :: E),d>) : (c :: (E, V) -> V)<(e1 :: E),d>, (@pat@1: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>))
         -> (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>,((c :: (E, V) -> V)<(e1 :: E),d>) -> (e :: E) (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>>((op<(e1 :: E),d>))(h))) {
          ((@skip std/core/hnd/Clause1((f: ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d> ) as @pat@2: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>))
             -> std/core/hnd/cast-clause1<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d>(f)(m, ev, x);
        });
    });
  };
inline  fun @perform2 // inline size: 4
  = forall<a,b,c,(e :: E),(d :: (E, V) -> V)> fn<(e :: E)>(evx: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, op: forall<(e1 :: E),a1> ((d :: (E, V) -> V)<(e1 :: E),a1>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>, x: a, y: b){
    (match (evx) {
      ((@skip std/core/hnd/Ev<(e1 :: E),a1>((@pat@0: (htag :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, (m: (marker :: (E, V) -> V)<(e1 :: E),a1>) : (marker :: (E, V) -> V)<(e1 :: E),a1>, (h: (d :: (E, V) -> V)<(e1 :: E),a1>) : (d :: (E, V) -> V)<(e1 :: E),a1>, (@pat@1: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>))
         -> (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),((d :: (E, V) -> V)<(e1 :: E),a1>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>,((d :: (E, V) -> V)<(e1 :: E),a1>) -> (e :: E) (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>>((op<(e1 :: E),a1>))(h))) {
          ((@skip std/core/hnd/Clause2((f: ((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e1 :: E) c) : ((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e1 :: E) c) : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1> ) as @pat@2: ((clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>))
             -> std/core/hnd/cast-clause2<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1>(f)(m, evx, x, y);
        });
    });
  };
 fun xperform1 // inline size: 4
  = forall<a,b,(e :: E),(c :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op: forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x: a){
    (match (ev) {
      ((@skip std/core/hnd/Ev<(e1 :: E),d>((@pat@0: (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, (m: (marker :: (E, V) -> V)<(e1 :: E),d>) : (marker :: (E, V) -> V)<(e1 :: E),d>, (h: (c :: (E, V) -> V)<(e1 :: E),d>) : (c :: (E, V) -> V)<(e1 :: E),d>, (@pat@1: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>))
         -> (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>,((c :: (E, V) -> V)<(e1 :: E),d>) -> (e :: E) (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>>((op<(e1 :: E),d>))(h))) {
          ((@skip std/core/hnd/Clause1((f: ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d> ) as @pat@2: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>))
             -> std/core/hnd/cast-clause1<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d>(f)(m, ev, x);
        });
    });
  };
 fun clause-tail-noop0 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c> fn(op: () -> (e :: E) c){
    std/core/hnd/Clause0<c,(b :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(@_wildcard-x737_14: (marker :: (E, V) -> V)<(e :: E),a>, @_wildcard-x737_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (op());
    }));
  };
 fun clause-tail-noop1 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d> fn(op: (c) -> (e :: E) d){
    std/core/hnd/Clause1<c,d,(b :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(@_wildcard-x691_14: (marker :: (E, V) -> V)<(e :: E),a>, @_wildcard-x691_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, x: c){
      (op(x));
    }));
  };
 fun clause-tail-noop2 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1> fn(op: (c, d) -> (e :: E) a1){
    std/core/hnd/Clause2<c,d,a1,(b :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(@_wildcard-x779_14: (marker :: (E, V) -> V)<(e :: E),a>, @_wildcard-x779_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, x1: c, x2: d){
      (op(x1, x2));
    }));
  };
 fun evv-swap-with // inline size: 1
  = forall<(a :: (E, V) -> V),(e :: E)> fn(ev: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (ev) {
      ((@skip std/core/hnd/Ev<(e1 :: E),b>((@pat@0: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (@pat@1: (marker :: (E, V) -> V)<(e1 :: E),b>) : (marker :: (E, V) -> V)<(e1 :: E),b>, (@pat@2: (a :: (E, V) -> V)<(e1 :: E),b>) : (a :: (E, V) -> V)<(e1 :: E),b>, (w: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> std/core/hnd/evv-swap<(std/core/types/total :: E),(e1 :: E),(e :: E)>(w);
    });
  };
 fun clause-value // inline size: 1
  = forall<a,(e :: E),(b :: (E, V) -> V),c> fn(v: a){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(@_wildcard-x740_14: (marker :: (E, V) -> V)<(e :: E),c>, @_wildcard-x740_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      v;
    }));
  };
 fun get // inline size: 1
  = forall<a,(h :: H)> fn<<(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/div :: X)>>(ref: (std/core/types/ref :: (H, V) -> V)<(h :: H),a>){
    std/core/types/#ref/(!)<(h :: H),a,<(std/core/types/div :: X)>>(ref);
  };
 fun resume // inline size: 4
  = forall<a,(e :: E),(e1 :: E),b> fn<(e :: E)>(r: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x: a){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (e :: E) (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b)>((fn(@this: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>){
      (match (@this) {
        ((@skip std/core/hnd/Resume-context((@x: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b> ) as @pat: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>))
           -> @x;
      });
    }))(r)((std/core/hnd/Deep<a,b>(x)));
  };
inline  fun htag/show // inline size: 0
  = forall<(a :: (E, V) -> V)> fn(@pat-x127_20: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (@pat-x127_20) {
      ((@skip std/core/hnd/Htag((tag: std/core/types/string) : std/core/types/string) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat: ((htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> tag;
    });
  };
inline  fun yield-bind // inline size: 0
  = forall<a,b,(e :: E)> fn<(e :: E)>(x: a, next: (a) -> (e :: E) b){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<a,b,(e :: E)>(next);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> next(x);
    });
  };
 fun clause-control-raw0 // inline size: 4
  = forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> fn(op: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),c>) -> (e :: E) c){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),c>, @_wildcard-x722_16: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (std/core/hnd/yield-to<a,(e :: E),c>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<a,c>) -> (e :: E) c){
          (op((std/core/hnd/Resume-context<a,(e :: E),(e1 :: E),c>(k))));
        })));
    }));
  };
 fun clause-control-raw1 // inline size: 4
  = forall<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d> fn(op: (x : a, r : (resume-context :: (V, E, E, V) -> V)<b,(e :: E),(e1 :: E),d>) -> (e :: E) d){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),d>, @_wildcard-x648_16: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, x: a){
      (std/core/hnd/yield-to<b,(e :: E),d>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<b,d>) -> (e :: E) d){
          (op(x, (std/core/hnd/Resume-context<b,(e :: E),(e1 :: E),d>(k))));
        })));
    }));
  };
 fun clause-control-raw2 // inline size: 4
  = forall<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1> fn(op: (x1 : a, x2 : b, r : (resume-context :: (V, E, E, V) -> V)<c,(e :: E),(e1 :: E),a1>) -> (e :: E) a1){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),a1>, @_wildcard-x773_16: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x1: a, x2: b){
      (std/core/hnd/yield-to<c,(e :: E),a1>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<c,a1>) -> (e :: E) a1){
          (op(x1, x2, (std/core/hnd/Resume-context<c,(e :: E),(e1 :: E),a1>(k))));
        })));
    }));
  };
 fun clause-control-raw3 // inline size: 4
  = forall<a,b,c,d,(e :: E),(e1 :: E),(a1 :: (E, V) -> V),b1> fn(op: (x1 : a, x2 : b, x3 : c, r : (resume-context :: (V, E, E, V) -> V)<d,(e :: E),(e1 :: E),b1>) -> (e :: E) b1){
    std/core/hnd/Clause1<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),b1>, @_wildcard-x648_16: (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, x: (a, b, c)){
      (std/core/hnd/yield-to<d,(e :: E),b1>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<d,b1>) -> (e :: E) b1){
          (match (x) {
            ((@skip std/core/types/Tuple3((x1: a) : a, (x2: b) : b, (x3: c) : c) : (a, b, c) ) as @pat: (a, b, c))
               -> op(x1, x2, x3, (std/core/hnd/Resume-context<d,(e :: E),(e1 :: E),b1>(k)));
          });
        })));
    }));
  };
 fun finalize // inline size: 4
  = forall<a,(e :: E),(e1 :: E),b> fn<(e :: E)>(r: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x: b){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (e :: E) (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b)>((fn(@this: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>){
      (match (@this) {
        ((@skip std/core/hnd/Resume-context((@x: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b> ) as @pat: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>))
           -> @x;
      });
    }))(r)((std/core/hnd/Finalize<a,b>(x)));
  };
 fun clause-control0 // inline size: 4
  = forall<a,(e :: E),(b :: (E, V) -> V),c> fn(op: ((a) -> (e :: E) c) -> (e :: E) c){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),c>, @_wildcard-x730_16: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (std/core/hnd/yield-to<a,(e :: E),c>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<a,c>) -> (e :: E) c){
          (std/core/hnd/protect<(),a,(e :: E),c>(std/core/types/Unit, (fn<(e :: E)>(@_wildcard-x730_55: (), r: (a) -> (e :: E) c){
              (op(r));
            }), k));
        })));
    }));
  };
 fun clause-control1 // inline size: 3
  = forall<a,b,(e :: E),(c :: (E, V) -> V),d> fn(clause: (x : a, k : (b) -> (e :: E) d) -> (e :: E) d){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),d>, @_wildcard-x681_16: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, x: a){
      (std/core/hnd/yield-to<b,(e :: E),d>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<b,d>) -> (e :: E) d){
          (std/core/hnd/protect<a,b,(e :: E),d>(x, clause, k));
        })));
    }));
  };
 fun clause-control2 // inline size: 3
  = forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> fn(clause: (x1 : a, x2 : b, k : (c) -> (e :: E) a1) -> (e :: E) a1){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),a1>, @_wildcard-x769_16: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x1: a, x2: b){
      (std/core/hnd/yield-to<c,(e :: E),a1>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<c,a1>) -> (e :: E) a1){
          (std/core/hnd/protect2<a,b,c,(e :: E),a1>(x1, x2, clause, k));
        })));
    }));
  };
 fun clause-control3 // inline size: 4
  = forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> fn(op: (x1 : a, x2 : b, x3 : c, k : (d) -> (e :: E) b1) -> (e :: E) b1){
    std/core/hnd/Clause1<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),b1>, @_wildcard-x681_16: (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, x: (a, b, c)){
      (std/core/hnd/yield-to<d,(e :: E),b1>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<d,b1>) -> (e :: E) b1){
          (std/core/hnd/protect<(a, b, c),d,(e :: E),b1>(x, (fn<(e :: E)>(@pat-x805_23: (a, b, c), k@0: (d) -> (e :: E) b1){
              (match (@pat-x805_23) {
                ((@skip std/core/types/Tuple3((x1: a) : a, (x2: b) : b, (x3: c) : c) : (a, b, c) ) as @pat: (a, b, c))
                   -> op(x1, x2, x3, k@0);
              });
            }), k));
        })));
    }));
  };
 fun clause-control4 // inline size: 4
  = forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> fn(op: (x1 : a, x2 : b, x3 : c, x4 : d, k : (a1) -> (e :: E) c1) -> (e :: E) c1){
    std/core/hnd/Clause1<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),c1>, @_wildcard-x681_16: (ev :: ((E, V) -> V) -> V)<(b1 :: (E, V) -> V)>, x: (a, b, c, d)){
      (std/core/hnd/yield-to<a1,(e :: E),c1>(m, (fn<(e :: E)>(k: ((resume-result :: (V, V) -> V)<a1,c1>) -> (e :: E) c1){
          (std/core/hnd/protect<(a, b, c, d),a1,(e :: E),c1>(x, (fn<(e :: E)>(@pat-x829_23: (a, b, c, d), k@0: (a1) -> (e :: E) c1){
              (match (@pat-x829_23) {
                ((@skip std/core/types/Tuple4((x1: a) : a, (x2: b) : b, (x3: c) : c, (x4: d) : d) : (a, b, c, d) ) as @pat: (a, b, c, d))
                   -> op(x1, x2, x3, x4, k@0);
              });
            }), k));
        })));
    }));
  };
 fun clause-never0 // inline size: 3
  = forall<a,(e :: E),(b :: (E, V) -> V),c> fn(op: () -> (e :: E) c){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),c>, @_wildcard-x743_16: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (std/core/hnd/yield-to-final<a,(e :: E),(e :: E),c>(m, (fn<(e :: E)>(@_wildcard-x743_43: ((resume-result :: (V, V) -> V)<a,c>) -> (e :: E) c){
          (op());
        })));
    }));
  };
 fun clause-never1 // inline size: 3
  = forall<a,b,(e :: E),(c :: (E, V) -> V),d> fn(op: (a) -> (e :: E) d){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),d>, @_wildcard-x696_16: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, x: a){
      (std/core/hnd/yield-to-final<b,(e :: E),(e :: E),d>(m, (fn<(e :: E)>(@_wildcard-x696_45: ((resume-result :: (V, V) -> V)<b,d>) -> (e :: E) d){
          (op(x));
        })));
    }));
  };
 fun clause-never2 // inline size: 3
  = forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> fn(op: (a, b) -> (e :: E) a1){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),a1>, @_wildcard-x787_16: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x1: a, x2: b){
      (std/core/hnd/yield-to-final<c,(e :: E),(e :: E),a1>(m, (fn<(e :: E)>(@_wildcard-x787_49: ((resume-result :: (V, V) -> V)<c,a1>) -> (e :: E) a1){
          (op(x1, x2));
        })));
    }));
  };
 fun clause-never3 // inline size: 3
  = forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> fn(op: (a, b, c) -> (e :: E) b1){
    std/core/hnd/Clause1<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),b1>, @_wildcard-x696_16: (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, x: (a, b, c)){
      (std/core/hnd/yield-to-final<d,(e :: E),(e :: E),b1>(m, (fn<(e :: E)>(@_wildcard-x696_45: ((resume-result :: (V, V) -> V)<d,b1>) -> (e :: E) b1){
          (match (x) {
            ((@skip std/core/types/Tuple3((x1: a) : a, (x2: b) : b, (x3: c) : c) : (a, b, c) ) as @pat: (a, b, c))
               -> op(x1, x2, x3);
          });
        })));
    }));
  };
 fun clause-never4 // inline size: 3
  = forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> fn(op: (a, b, c, d) -> (e :: E) c1){
    std/core/hnd/Clause1<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),c1>, @_wildcard-x696_16: (ev :: ((E, V) -> V) -> V)<(b1 :: (E, V) -> V)>, x: (a, b, c, d)){
      (std/core/hnd/yield-to-final<a1,(e :: E),(e :: E),c1>(m, (fn<(e :: E)>(@_wildcard-x696_45: ((resume-result :: (V, V) -> V)<a1,c1>) -> (e :: E) c1){
          (match (x) {
            ((@skip std/core/types/Tuple4((x1: a) : a, (x2: b) : b, (x3: c) : c, (x4: d) : d) : (a, b, c, d) ) as @pat: (a, b, c, d))
               -> op(x1, x2, x3, x4);
          });
        })));
    }));
  };
 fun clause-tail-noop3 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1> fn(op: (c, d, a1) -> (e :: E) b1){
    std/core/hnd/Clause1<(c, d, a1),b1,(b :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(@_wildcard-x691_14: (marker :: (E, V) -> V)<(e :: E),a>, @_wildcard-x691_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, x: (c, d, a1)){
      (match (x) {
        ((@skip std/core/types/Tuple3((x1: c) : c, (x2: d) : d, (x3: a1) : a1) : (c, d, a1) ) as @pat: (c, d, a1))
           -> op(x1, x2, x3);
      });
    }));
  };
 fun clause-tail-noop4 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1,c1> fn(op: (c, d, a1, b1) -> (e :: E) c1){
    std/core/hnd/Clause1<(c, d, a1, b1),c1,(b :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(@_wildcard-x691_14: (marker :: (E, V) -> V)<(e :: E),a>, @_wildcard-x691_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, x: (c, d, a1, b1)){
      (match (x) {
        ((@skip std/core/types/Tuple4((x1: c) : c, (x2: d) : d, (x3: a1) : a1, (x4: b1) : b1) : (c, d, a1, b1) ) as @pat: (c, d, a1, b1))
           -> op(x1, x2, x3, x4);
      });
    }));
  };
inline  fun under1 // inline size: 12
  = forall<a,b,(e :: E),(c :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op: (a) -> (e :: E) b, x: a){
    val w0[631,7,631,8] : (evv :: E -> V)<(_e1 :: E)>
      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (evv :: E -> V)<(_e1 :: E)>,(ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(_e1 :: E)>>((fn(ev@0: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>){
        (match (ev@0) {
          ((@skip std/core/hnd/Ev<(e1 :: E),d>((@pat@0: (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, (@pat@1: (marker :: (E, V) -> V)<(e1 :: E),d>) : (marker :: (E, V) -> V)<(e1 :: E),d>, (@pat@2: (c :: (E, V) -> V)<(e1 :: E),d>) : (c :: (E, V) -> V)<(e1 :: E),d>, (w: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>))
             -> std/core/hnd/evv-swap<(std/core/types/total :: E),(e1 :: E),(_e2 :: E)>(w);
        });
      }))(ev);
    val y[632,7,632,7] : b
      = op(x);
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as @pat@3: std/core/types/bool)
         -> std/core/hnd/yield-cont<b,(e :: E),b>((forall<d> fn<(e :: E)>(cont: (d) -> (e :: E) b, res: d){
          std/core/hnd/under1x<d,b,(e :: E),(c :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>,(x : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (e :: E) (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>>((std/core/undiv/pretend-decreasing<(ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>>))(ev)), cont, res);
        }));
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@0: std/core/types/bool)
         -> val _@0[635,3,635,13] : ()
                  = std/core/hnd/evv-set<(e :: E),(_e1 :: E)>(w0);
        y;
    });
  };
inline  fun under0 // inline size: 21
  = forall<a,(e :: E),(b :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op: () -> (e :: E) a){
    val w0[714,7,714,8] : (evv :: E -> V)<(_e1 :: E)>
      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (evv :: E -> V)<(_e1 :: E)>,(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(_e1 :: E)>>((fn(ev@0: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
        (match (ev@0) {
          ((@skip std/core/hnd/Ev<(e1 :: E),c>((@pat@0: (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, (@pat@1: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (@pat@2: (b :: (E, V) -> V)<(e1 :: E),c>) : (b :: (E, V) -> V)<(e1 :: E),c>, (w: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>))
             -> std/core/hnd/evv-swap<(std/core/types/total :: E),(e1 :: E),(_e2 :: E)>(w);
        });
      }))(ev);
    val y[715,7,715,7] : a
      = op();
    val _[717,3,717,13] : ()
      = std/core/hnd/evv-set<(e :: E),(_e1 :: E)>(w0);
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as @pat@3: std/core/types/bool)
         -> std/core/hnd/yield-cont<a,(e :: E),a>((forall<c> fn<(e :: E)>(cont: (c) -> (e :: E) a, res: c){
          val w0@0[631,7,631,8] : (evv :: E -> V)<(_e1 :: E)>
            = std/core/types/@open<(std/core/types/total :: E),(e :: E),(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (evv :: E -> V)<(_e1 :: E)>,(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(_e1 :: E)>>((fn(ev@2: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
              (match (ev@2) {
                ((@skip std/core/hnd/Ev<(e1 :: E),d>((@pat@0@0: (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, (@pat@1@0: (marker :: (E, V) -> V)<(e1 :: E),d>) : (marker :: (E, V) -> V)<(e1 :: E),d>, (@pat@2@0: (b :: (E, V) -> V)<(e1 :: E),d>) : (b :: (E, V) -> V)<(e1 :: E),d>, (w@0: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)> ) as @pat@4: ((ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>))
                   -> std/core/hnd/evv-swap<(std/core/types/total :: E),(e1 :: E),(_e2 :: E)>(w@0);
              });
            }))(ev);
          val y@0[632,7,632,7] : a
            = cont(res);
          (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
            ((std/core/types/True() : std/core/types/bool ) as @pat@5: std/core/types/bool)
               -> std/core/hnd/yield-cont<a,(e :: E),a>((forall<d> fn<(e :: E)>(cont@0: (d) -> (e :: E) a, res@0: d){
                std/core/hnd/under1x<d,a,(e :: E),(b :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>,(x : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>>((std/core/undiv/pretend-decreasing<(ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>>))(ev)), cont@0, res@0);
              }));
            ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@1: std/core/types/bool)
               -> val _@0[635,3,635,13] : ()
                        = std/core/hnd/evv-set<(e :: E),(_e1 :: E)>(w0@0);
              y@0;
          });
        }));
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@2: std/core/types/bool)
         -> y;
    });
  };
 fun clause-tail2 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1> fn(op: (c, d) -> (e :: E) a1){
    std/core/hnd/Clause2<c,d,a1,(b :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(m: (marker :: (E, V) -> V)<(e :: E),a>, ev: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, x1: c, x2: d){
      (std/core/hnd/under2<c,d,a1,(e :: E),(b :: (E, V) -> V)>(ev, op, x1, x2));
    }));
  };
 fun clause-tail3 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1> fn(op: (c, d, a1) -> (e :: E) b1){
    std/core/hnd/clause-tail1<(e :: E),a,(b :: (E, V) -> V),(c, d, a1),b1>((fn<(e :: E)>(@pat-x808_20: (c, d, a1)){
      (match (@pat-x808_20) {
        ((@skip std/core/types/Tuple3((x1: c) : c, (x2: d) : d, (x3: a1) : a1) : (c, d, a1) ) as @pat: (c, d, a1))
           -> op(x1, x2, x3);
      });
    }));
  };
 fun clause-tail4 // inline size: 2
  = forall<(e :: E),a,(b :: (E, V) -> V),c,d,a1,b1,c1> fn(op: (c, d, a1, b1) -> (e :: E) c1){
    std/core/hnd/clause-tail1<(e :: E),a,(b :: (E, V) -> V),(c, d, a1, b1),c1>((fn<(e :: E)>(@pat-x832_20: (c, d, a1, b1)){
      (match (@pat-x832_20) {
        ((@skip std/core/types/Tuple4((x1: c) : c, (x2: d) : d, (x3: a1) : a1, (x4: b1) : b1) : (c, d, a1, b1) ) as @pat: (c, d, a1, b1))
           -> op(x1, x2, x3, x4);
      });
    }));
  };
 fun finally // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(fin: () -> (e :: E) (), action: () -> (e :: E) a){
    std/core/hnd/finally-prompt<a,(e :: E)>(fin, (action()));
  };
inline  fun local-var // inline size: 9
  = forall<a,b,(e :: E),(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(init: a, action: (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b){
    std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(action : () -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> (() -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b),(action : () -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (() -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b)>((std/core/undiv/pretend-nodiv-cast<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,b>))((fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(){
      val loc[508,9,508,11] : ((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>)
        = (std/core/types/local-new<a,<(std/core/types/div :: X)|(e :: E)>,(h :: H)>(init));
      val res[509,9,509,11] : b
        = (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(f : ((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> (((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b),(f : ((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b)>((std/core/hnd/cast-ev1<(std/core/types/local-var :: (H, V) -> V)<(h :: H),a>,b,<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>))(action)(loc));
      (std/core/types/@open<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>,<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(loc : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>, res : b) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>> b,(loc : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>, res : b) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b>((std/core/hnd/prompt-local-var<a,b,(h :: H)>))(loc, res));
    }))();
  };
 fun local-var-vm // inline size: 1
  = forall<a,b,(e :: E),(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(init: a, action: (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b){
    std/core/hnd/@prompt-local-var-prim-vm<a,b,(e :: E),(h :: H)>(init, action);
  };
 fun unsafe-try-finalize // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> (e :: E) a){
    std/core/hnd/try-finalize-prompt<a,(e :: E)>((action()));
  };
inline  fun yield-bind2 // inline size: 0
  = forall<a,b,(e :: E)> fn<(e :: E)>(x: a, extend: (a) -> (e :: E) b, next: (a) -> (e :: E) b){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<a,b,(e :: E)>(extend);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> next(x);
    });
  };
 fun ev/(==) // inline size: 1
  = forall<(a :: (E, V) -> V)> fn(@pat-x142_18: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, @pat-x142_37: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (@pat-x142_18) {
      ((@skip std/core/hnd/Ev<(e :: E),b>((@pat@0: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (m1: (marker :: (E, V) -> V)<(e :: E),b>) : (marker :: (E, V) -> V)<(e :: E),b>, (@pat@1: (a :: (E, V) -> V)<(e :: E),b>) : (a :: (E, V) -> V)<(e :: E),b>, (@pat@2: (evv :: E -> V)<(e :: E)>) : (evv :: E -> V)<(e :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> (match (@pat-x142_37) {
          ((@skip std/core/hnd/Ev<(e1 :: E),c>((@pat@4: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (m2: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (@pat@5: (a :: (E, V) -> V)<(e1 :: E),c>) : (a :: (E, V) -> V)<(e1 :: E),c>, (@pat@6: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as @pat@3: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
             -> std/core/hnd/eq-marker<b,c,(e :: E),(e1 :: E)>(m1, m2);
        });
    });
  };