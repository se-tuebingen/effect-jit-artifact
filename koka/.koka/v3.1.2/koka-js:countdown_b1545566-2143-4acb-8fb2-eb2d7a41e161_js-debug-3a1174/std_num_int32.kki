// 32-bit signed integers.
//
// Using 32-bit signed two's complement representation with wrapping on overflow,
// e.g. `max-int32 + 1.int32 == min-int32`.
module interface std/num/int32
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/core/undiv = std/core/undiv = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
// Take the bitwise _xor_ of two `:int32`s
pub fip fun (^)[238,12,238,14] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32;
pub fip fun cmp[198,13,198,15] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/order;
// Full 32x32 bit signed multiply to `(hi,lo)`.
// where `(hi,lo).int == hi.int * 0x1_0000_0000 + lo.uint`
pub fip fun imul[399,16,399,19] : (i : std/core/types/int32, j : std/core/types/int32) -> (std/core/types/int32, std/core/types/int32);
// Return the maximum of two integers
pub fip fun max[387,13,387,15] : (i : std/core/types/int32, j : std/core/types/int32) -> std/core/types/int32;
// Return the minimum of two integers
pub fip fun min[383,13,383,15] : (i : std/core/types/int32, j : std/core/types/int32) -> std/core/types/int32;
// Compare the argument against zero.
pub fip fun sign[166,13,166,16] : (i : std/core/types/int32) -> std/core/types/order;
// Full 32x32 bit unsigned multiply to `(hi,lo)`.
// where `(hi,lo).uint == hi.uint * 0x1_0000_0000 + lo.uint`
pub fip fun umul[393,16,393,19] : (i : std/core/types/int32, j : std/core/types/int32) -> (std/core/types/int32, std/core/types/int32);
// The 32-bit integer with value 1.
pub val one[163,9,163,11] : std/core/types/int32;
// The zero 32-bit integer.
pub val zero[160,9,160,12] : std/core/types/int32;
// Convert a boolean to an `:int32`.
pub fip fun bool/int32[68,13,68,22] : (b : std/core/types/bool) -> std/core/types/int32;
// Create an `:int32` from the give `hi` and `lo` 16-bit numbers.
// Preserves the sign of `hi`.
pub  fun hilo/int32[287,9,287,18] : (hi : std/core/types/int32, lo : std/core/types/int32) -> std/core/types/int32;
// The minimal integer value before underflow happens
pub val min-int32[24,9,24,17] : std/core/types/int32;
// Euclidean-0 modulus. See `(/):(x : int32, y : int32) -> int32` division for more information.
pub fip fun (%)[491,13,491,15] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32;
/*
Euclidean-0 division.
Euclidean division is defined as: For any `D`  and `d`  where `d!=0` , we have:

1. `D == d*(D/d) + (D%d)`
2. `D%d`  is always positive where `0 <= D%d < abs(d)`

Moreover, Euclidean-0 is a total function, for the case where `d==0`  we have
that `D%0 == D`  and `D/0 == 0` . So property (1) still holds, but not property (2).
Useful laws that hold for Euclidean-0 division:

* `D/(-d) == -(D/d)`
* `D%(-d) == D%d`
* `D/(2^n) == sar(D,n)         `  (with `0 <= n <= 31`)
* `D%(2^n) == D & ((2^n) - 1)  `  (with `0 <= n <= 31`)

Note that an interesting edge case is `min-int32 / -1` which equals `min-int32` since in modulo 32-bit
arithmetic `min-int32 == -1 * min-int32 == -1 * (min-int32 / -1) + (min-int32 % -1)` satisfying property (1).
Of course `(min-int32 + 1) / -1` is again positive (namely `max-int32`).

See also _Division and modulus for computer scientists, Daan Leijen, 2001_
[pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf) .
*/
pub fip fun (/)[480,13,480,15] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32;
// Negate a 32-bit integer
pub fip fun negate[448,13,448,18] : (i : std/core/types/int32) -> std/core/types/int32;
// Return the absolute value of an integer.
// Raises an exception if the `:int32` is `min-int32`
// (since the negation of `min-int32` equals itself and is still negative)
pub  fun abs[207,9,207,11] : (i : std/core/types/int32) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/int32;
// Return the absolute value of an integer.
// Returns 0 if the `:int32` is `min-int32`
// (since the negation of `min-int32` equals itself and is still negative)
pub fip fun abs0[216,13,216,16] : (i : std/core/types/int32) -> std/core/types/int32;
// The number of bits in an `:int32` (always 32)
pub val bits-int32[27,9,27,18] : std/core/types/int32;
// Convert an `:int32` to a boolean.
pub fip fun bool[63,13,63,16] : (i : std/core/types/int32) -> std/core/types/bool;
// Truncated division (as in C). See also `(/):(x : int32, y : int32) -> int32`.
pub  fun cdiv[415,9,415,12] : (i : std/core/types/int32, j : std/core/types/int32) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/int32;
// Truncated modulus (as in C). See also `(%):(x : int32, y : int32) -> int32`.
pub  fun cmod[422,9,422,12] : (i : std/core/types/int32, j : std/core/types/int32) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/int32;
// Decrement a 32-bit integer.
pub fip fun dec[188,13,188,15] : (i : std/core/types/int32) -> std/core/types/int32;
// Increment a 32-bit integer.
pub fip fun inc[183,13,183,15] : (i : std/core/types/int32) -> std/core/types/int32;
pub fip fun divmod[500,13,500,18] : (x : std/core/types/int32, y : std/core/types/int32) -> (std/core/types/int32, std/core/types/int32);
// monadic lift
 fun range/@mlift-fold-int32@10071[1,0,1,0] : forall<a,(e :: E)> (end : std/core/types/int32, f : (std/core/types/int32, a) -> (e :: E) a, start : std/core/types/int32, x : a) -> (e :: E) a;
// Fold over the range `[start,end]` (including `end`).
pub fip fun range/fold-int32[511,13,511,28] : forall<a,(e :: E)> (start : std/core/types/int32, end : std/core/types/int32, init : a, ^ f : (std/core/types/int32, a) -> (e :: E) a) -> (e :: E) a;
// Fold over the 32-bit integers `0` to `n-1`.
pub fip fun fold-int32[517,13,517,22] : forall<a,(e :: E)> (n : std/core/types/int32, init : a, ^ f : (std/core/types/int32, a) -> (e :: E) a) -> (e :: E) a;
// monadic lift
 fun range/@mlift-fold-while-int32@10072[1,0,1,0] : forall<a,(e :: E)> (end : std/core/types/int32, f : (std/core/types/int32, a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, init : a, start : std/core/types/int32, @y-x10044 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) a;
// Iterate over the range `[start,end]` (including `end`).
pub  fun range/fold-while-int32[522,9,522,30] : forall<a,(e :: E)> (start : std/core/types/int32, end : std/core/types/int32, init : a, f : (std/core/types/int32, a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) a;
// Iterate over the 32-bit integers `0` to `n-1`.
pub  fun fold-while-int32[529,9,529,24] : forall<a,(e :: E)> (n : std/core/types/int32, init : a, f : (std/core/types/int32, a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) a;
// monadic lift
 fun range/@mlift-lift-for-while32@2275@10073[1,0,1,0] : forall<a,(e :: E)> (action : (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/int32, i : std/core/types/int32, @y-x10049 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted local: range/for-while32, rep
 fun range/@lift-for-while32@2275[1,0,1,0] : forall<a,(e :: E)> (action : (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/int32, i : std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
pub  fun range/for-while32[549,9,549,25] : forall<a,(e :: E)> (start : std/core/types/int32, end : std/core/types/int32, action : (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
pub  fun for-while32[558,9,558,19] : forall<a,(e :: E)> (n : std/core/types/int32, action : (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// monadic lift
 fun range/@mlift-lift-for32@2276@10074[1,0,1,0] : forall<(e :: E)> (action : (std/core/types/int32) -> (e :: E) (), end : std/core/types/int32, i : std/core/types/int32, wild_ : ()) -> (e :: E) ();
// lifted local: range/for32, rep
 fun range/@lift-for32@2276[1,0,1,0] : forall<(e :: E)> (action : (std/core/types/int32) -> (e :: E) (), end : std/core/types/int32, i : std/core/types/int32) -> (e :: E) ();
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
pub  fun range/for32[535,9,535,19] : forall<(e :: E)> (start : std/core/types/int32, end : std/core/types/int32, action : (std/core/types/int32) -> (e :: E) ()) -> (e :: E) ();
pub  fun for32[542,9,542,13] : forall<(e :: E)> (n : std/core/types/int32, action : (std/core/types/int32) -> (e :: E) ()) -> (e :: E) ();
// Return the top 16-bits of an `:int32`.
// Preserves the sign.
pub  fun hi[278,9,278,10] : (i : std/core/types/int32) -> std/core/types/int32;
// Convenient shorthand to `int32`, e.g. `1234.i32`
pub fip fun i32[34,20,34,22] : (i : std/core/types/int) -> std/core/types/int32;
// Returns `true` if the integer `i`  is an even number.
pub fip fun is-even[178,13,178,19] : (i : std/core/types/int32) -> std/core/types/bool;
// Returns `true` if the integer `i`  is an odd number.
pub fip fun is-odd[173,13,173,18] : (i : std/core/types/int32) -> std/core/types/bool;
// Create a list with 32-bit integer elements from `lo` to `hi` (including `hi`).
pub  fun @trmc-list32[563,9,563,14] : (lo : std/core/types/int32, hi : std/core/types/int32, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/int32>>) -> (std/core/types/list :: V -> V)<std/core/types/int32>;
// Create a list with 32-bit integer elements from `lo` to `hi` (including `hi`).
pub  fun list32[563,9,563,14] : (lo : std/core/types/int32, hi : std/core/types/int32) -> (std/core/types/list :: V -> V)<std/core/types/int32>;
// Return the low 16-bits of an `:int32`.
pub  fun lo[282,9,282,10] : (i : std/core/types/int32) -> std/core/types/int32;
// The maximal integer value before overflow happens
pub val max-int32[21,9,21,17] : std/core/types/int32;
// Bitwise rotate an `:int32` `n % 32` bits to the left.
pub fip fun rotl[296,13,296,16] : (i : std/core/types/int32, shift : std/core/types/int) -> std/core/types/int32;
// Bitwise rotate an `:int32` `n % 32` bits to the right.
pub fip fun rotr[305,13,305,16] : (i : std/core/types/int32, shift : std/core/types/int) -> std/core/types/int32;
// Arithmetic shift an `:int32` to the right by `n % 32` bits. Shifts in the sign bit from the left.
pub fip fun sar[273,13,273,15] : (i : std/core/types/int32, shift : std/core/types/int) -> std/core/types/int32;
// Shift an `:int32` `i` to the left by `n & 31` bits.
pub fip fun shl[252,13,252,15] : (i : std/core/types/int32, shift : std/core/types/int) -> std/core/types/int32;
// Convert an `:int32` to an `:int` but interpret the `:int32` as a 32-bit unsigned value.
pub  fun uint[91,9,91,12] : (i : std/core/types/int32) -> std/core/types/int;
// Convert a pair `(lo,hi)` to a signed integer,
// where `(lo,hi).int == hi.int * 0x1_0000_0000 + lo.uint`
pub  fun hilo/int[405,9,405,16] : (@pat-x405_19 : (std/core/types/int32, std/core/types/int32)) -> std/core/types/int;
// Convert a pair `(lo,hi)` to an unsigned integer,
// where `(lo,hi).uint == hi.uint * 0x1_0000_0000 + lo.uint`
pub  fun hilo/uint[410,9,410,17] : (@pat-x410_20 : (std/core/types/int32, std/core/types/int32)) -> std/core/types/int;
// Convert an `:int32` to a string
pub  fun show[30,9,30,12] : (i : std/core/types/int32) -> std/core/types/string;
// Show an `:int32` in hexadecimal notation
// The `width`  parameter specifies how wide the hex value is where `'0'`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number (goes between the sign and the number).
pub  fun show-hex[77,9,77,16] : (i : std/core/types/int32, width : (std/core/types/@optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/@optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/@optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show an `:int32` in hexadecimal notation interpreted as an unsigned 32-bit value.
// The `width`  parameter specifies how wide the hex value is where `'0'`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number.
pub  fun show-hex32[99,9,99,18] : (i : std/core/types/int32, width : (std/core/types/@optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/@optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/@optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Logical shift an `:int32` to the right by `n % 32` bits. Shift in zeros from the left.
pub fip fun shr[262,13,262,15] : (i : std/core/types/int32, shift : std/core/types/int) -> std/core/types/int32;
fip fun sumacc32[572,9,572,16] : (^ xs : (std/core/types/list :: V -> V)<std/core/types/int32>, acc : std/core/types/int32) -> std/core/types/int32;
pub fip fun sum32[568,13,568,17] : (^ xs : (std/core/types/list :: V -> V)<std/core/types/int32>) -> std/core/types/int32;
// Convert an `:int` to `:int32` but interpret the `int` as an unsigned 32-bit value.
// `i` is clamped between `0` and `0xFFFFFFFF`.\
// `0x7FFF_FFFF.uint32 == 0x7FFF_FFFF.int32 == max-int32`\
// `0x8000_0000.uint32 == -0x8000_0000.int32 == min-int32`\
// `0xFFFF_FFFF.uint32 == -1.int32`\
pub  fun uint32[86,9,86,14] : (i : std/core/types/int) -> std/core/types/int32;
// Negate an 32-bit integer
pub fip fun (~)[453,13,453,15] : (i : std/core/types/int32) -> std/core/types/int32;
 
//------------------------------
//#kki: external declarations
 
// Convert an integer to an `:int32`. The number is _clamped_ to the maximal or minimum `:int32`
// value if it is outside the range of an `:int32`.
// Needed for control flow contexts in `module std/core/hnd`
pub fip extern int32[40,23,40,27] : (i : std/core/types/int) -> std/core/types/int32 {
  c inline "kk_integer_clamp32(#1,kk_context())";
  cs inline "Primitive.IntToInt32(#1)";
  js inline "$std_core_types._int_clamp32(#1)";
  vm inline "!sexp:$arg0:num";
};
// Convert an `:int32` to an `:int`.
pub fip extern int[47,23,47,25] : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_int(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core_types._int_from_int32(#1)";
  vm inline "!sexp:$arg0:num";
};
// Are two 32-bit integers equal?
pub fip extern (==)[103,23,103,26] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
  vm inline "infixEq(Int, Int): Boolean";
};
// Are two 32-bit integers not equal?
pub fip extern (!=)[109,23,109,26] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
  vm inline "infixNeq(Int, Int): Boolean";
};
// Is the first 32-bit integer smaller or equal to the second?
pub fip extern (<=)[115,23,115,26] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool {
  inline "(#1 <= #2)";
  vm inline "infixLte(Int, Int): Boolean";
};
// Is the first 32-bit integer larger or equal to the second?
pub fip extern (>=)[120,23,120,26] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool {
  inline "(#1 >= #2)";
  vm inline "infixGte(Int, Int): Boolean";
};
// Is the first 32-bit integer smaller than the second?
pub fip extern (<)[125,23,125,25] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool {
  inline "(#1 < #2)";
  vm inline "infixLt(Int, Int): Boolean";
};
// Is the first 32-bit integer larger than the second?
pub fip extern (>)[130,23,130,25] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool {
  inline "(#1 > #2)";
  vm inline "infixGt(Int, Int): Boolean";
};
// Add two 32-bit integers.
pub fip extern (+)[135,23,135,25] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32 {
  c inline "(int32_t)((uint32_t)#1 + (uint32_t)#2)";
  js inline "((#1 + #2)|0)";
  vm inline "infixAdd(Int, Int): Int";
};
// Subtract two 32-bit integers.
pub fip extern (-)[141,23,141,25] : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32 {
  c inline "(int32_t)((uint32_t)#1 - (uint32_t)#2)";
  js inline "((#1 - #2)|0)";
  vm inline "infixSub(Int, Int): Int";
};
// Is the 32-bit integer negative?
pub fip extern is-neg[147,23,147,28] : (i : std/core/types/int32) -> std/core/types/bool = inline "0 > #1";
// Is the 32-bit integer positive (i.e. larger than zero)?
pub fip extern is-pos[151,23,151,28] : (i : std/core/types/int32) -> std/core/types/bool = inline "0 < #1";
// Is the 32-bit integer equal to zero?
pub fip extern is-zero[155,23,155,29] : (i : std/core/types/int32) -> std/core/types/bool {
  inline "0 == #1";
  js inline "0 === #1";
};
// Multiply two 32-bit integers.
pub fip extern (*)[193,23,193,25] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(int32_t)((uint32_t)#1 * (uint32_t)#2)";
  js inline "$std_core_types._int32_multiply(#1,#2)";
};
// Take the bitwise _and_ of two `:int32`s
pub fip extern and[224,23,224,25] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 & #2)";
// Take the bitwise _or_ of two `:int32`s
pub fip extern or[229,23,229,24] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 | #2)";
// Take the bitwise _xor_ of two `:int32`s
pub fip extern xor[234,23,234,25] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 ^ #2)";
// Bitwise _not_ of an `:int32`, i.e. flips all bits.
pub fip extern not[243,23,243,25] : (i : std/core/types/int32) -> std/core/types/int32 = inline "(~#1)";
// Shift an `:int32` `i` to the left by `n & 31` bits.
fip extern shl32[247,19,247,23] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_shl32(#1,#2)";
  js inline "#1 << #2";
};
// Logical shift an `:int32` to the right by `n % 32` bits. Shift in zeros from the left.
fip extern shr32[256,19,256,23] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  c inline "(int32_t)kk_shr32(#1,#2)";
  cs inline "(Int32)(((UInt32)#1)>>#2)";
  js inline "#1 >>> #2";
};
// Arithmetic shift an `:int32` to the right by `n % 32` bits. Shifts in the sign bit from the left.
fip extern sar32[267,19,267,23] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_sar32(#1,#2)";
  cs inline "(#1>>#2)";
  js inline "#1 >> #2";
};
// Bitwise rotate an `:int32` `n % 32` bits to the left.
fip extern rotl32[291,19,291,24] : (i : std/core/types/int32, n : std/core/types/int32) -> std/core/types/int32 {
  c inline "(int32_t)kk_bits_rotl32(#1,#2)";
  js inline "$std_core_types._int32_rotl(#1,#2)";
};
// Bitwise rotate an `:int32` `n % 32` bits to the right.
fip extern rotr32[300,19,300,24] : (i : std/core/types/int32, n : std/core/types/int32) -> std/core/types/int32 {
  c inline "(int32_t)kk_bits_rotr32(#1,#2)";
  js inline "$std_core_types._int32_rotr(#1,#2)";
};
// Count trailing zero bits. Returns 32 if `i` is zero.
pub fip extern ctz[310,23,310,25] : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_small(kk_bits_ctz32(#1))";
  js inline "$std_core_types._int32_ctz(#1)";
};
// Count leading zero bits. Returns 32 if `i` is zero.
pub fip extern clz[315,23,315,25] : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_small(kk_bits_clz32(#1))";
  js inline "$std_core_types._int32_clz(#1)";
};
// Count leading redundant sign bits (i.e. the number of bits
// following the most significant bit that are identical to it).
pub fip extern clrsb[321,23,321,27] : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_small(kk_bits_clrsb32(#1))";
  js inline "$std_core_types._int32_clrsb(#1)";
};
// Count number of 1-bits (also known as _population count_ or _hamming weight_).
pub fip extern popcount[327,23,327,30] : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_small(kk_bits_popcount32(#1))";
  js inline "$std_core_types._int32_bits_popcount(#1)";
};
// Is the number of 1-bits even?
pub fip extern parity[332,23,332,28] : (i : std/core/types/int32) -> std/core/types/bool {
  c inline "kk_bits_parity32(#1)";
  js inline "$std_core_types._int32_parity(#1)";
};
// Reverse the bytes in an `:int32`.
pub fip extern byteswap[337,23,337,30] : (i : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_bswap32(#1)";
  js inline "$std_core_types._int32_bswap(#1)";
};
// Reverse the bits in an `:int32`.
pub fip extern breverse[342,23,342,30] : (i : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_reverse32(#1)";
  js inline "$std_core_types._int32_breverse(#1)";
};
// Bit gather (also known as _pext_ or parallel bit extract).
// For each 1-bit in mask `m`, extract the corresponding bit from `i` and write it
// into contiguous lower bits in the result. The remaining bits in the result are zero.
//
// `bgather(0x1234.int32, 0x0F0F.int32).show-hex == "0x24"`
//
// Here is how to decode a 4-byte utf-8 encoded character `i`:
//
// `bgather(i,0x3F3F3F3F.int32)`
pub fip extern bgather[355,23,355,29] : (i : std/core/types/int32, m : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_gather32(#1,#2)";
};
// Bit scatter (also known as _pdep_ or parallel bit deposit).
// For each 1-bit in mask `m`, set the corresponding bit in the result from the
// contiguous lower bits of `i`. Any bits not set according to the mask are set to zero.
//
// `bscatter(0x1234.int32, 0x0F0F.int32).show-hex == "0x304"`
pub fip extern bscatter[363,23,363,30] : (i : std/core/types/int32, m : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_scatter32(#1,#2)";
};
// Interleave the hi 16-bits with the lo 16-bits of the argument `i` such
// that the hi bits are spread over the even bits and the lo bits over the odd bits of the result.
pub fip extern interleave[368,23,368,32] : (i : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_interleave32(#1)";
};
// De-interleave the bits in `i` such that the even bits are gathered in the
// hi 16-bits of the result, and the odd bits in the lo 16-bits of the result.
pub fip extern deinterleave[373,23,373,34] : (i : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_deinterleave32(#1)";
};
// Or-combine: for every byte `b` in the argument `i`, the corresponding
// byte in the result becomes 0 if `b==0`, and `0xFF` otherwise.
pub fip extern orc[378,23,378,25] : (i : std/core/types/int32) -> std/core/types/int32 {
  c inline "kk_bits_orc32(#1)";
};
// Truncated division (as in C). See also `(/):(x : int32, y : int32) -> int32`.
pub fip extern unsafe-cdiv[429,23,429,33] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 / #2)";
  js inline "((#1/#2)|0)";
};
// Truncated modulus (as in C). See also `(%):(x : int32, y : int32) -> int32`.
pub fip extern unsafe-cmod[435,23,435,33] : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 % #2)";
  js inline "((#1 % #2)|0)";
};
// Convert an 32-bit integer to a float64.
pub fip extern float64[441,23,441,29] : (i : std/core/types/int32) -> std/core/types/float64 {
  c inline "(double)(#1)";
  cs inline "(double)(#1)";
  js inline "(#1)";
};
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "__*" borrow "__^" fip fun fold-int32 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(n: std/core/types/int32, init: a, f: (std/core/types/int32, a) -> (e :: E) a){
    std/num/int32/#range/fold-int32<a,(e :: E)>(std/num/int32/zero, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i: std/core/types/int32){
        (std/num/int32/(-)(i, (std/num/int32/int32(1))));
      }))(n)), init, f);
  };
specialize "__*"  fun fold-while-int32 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(n: std/core/types/int32, init: a, f: (std/core/types/int32, a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/num/int32/#range/fold-while-int32<a,(e :: E)>(std/num/int32/zero, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i: std/core/types/int32){
        (std/num/int32/(-)(i, (std/num/int32/int32(1))));
      }))(n)), init, f);
  };
specialize "_*"  fun for-while32 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(n: std/core/types/int32, action: (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    val end@10010[1,0,1,0] : std/core/types/int32
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i@0: std/core/types/int32){
            (std/num/int32/(-)(i@0, (std/num/int32/int32(1))));
          }))(n);
    std/num/int32/#range/@lift-for-while32@2275<a,(e :: E)>(action, end@10010, std/num/int32/zero);
  };
specialize "_*"  fun for32 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(n: std/core/types/int32, action: (std/core/types/int32) -> (e :: E) ()){
    val end@10014[1,0,1,0] : std/core/types/int32
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i@0: std/core/types/int32){
            (std/num/int32/(-)(i@0, (std/num/int32/int32(1))));
          }))(n);
    std/num/int32/#range/@lift-for32@2276<(e :: E)>(action, end@10014, std/num/int32/zero);
  };
recursive specialize "*__"  fun range/@lift-for-while32@2275 // inline size: 13
  = forall<a,(e :: E)> fn<(e :: E)>(action: (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end: std/core/types/int32, i: std/core/types/int32){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool,(x : std/core/types/int32, y : std/core/types/int32) -> (e :: E) std/core/types/bool>(std/num/int32/(<=))(i, end))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> (match ((action(i))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat@0: ((std/core/types/maybe :: V -> V)<a>))
             -> val i@0@10008[1,0,1,0] : std/core/types/int32
                      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32) -> std/core/types/int32,(x : std/core/types/int32) -> (e :: E) std/core/types/int32>((std/core/undiv/pretend-decreasing<std/core/types/int32>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i@1: std/core/types/int32){
                        (std/num/int32/(+)(i@1, (std/num/int32/int32(1))));
                      }))(i)));
            std/num/int32/#range/@lift-for-while32@2275<a,(e :: E)>(action, end, i@0@10008);
          ((@skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@1: ((std/core/types/maybe :: V -> V)<a>))
             -> std/core/types/Just<a>(x);
        });
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
         -> std/core/types/Nothing<a>;
    });
  };
recursive specialize "*__"  fun range/@lift-for32@2276 // inline size: 11
  = forall<(e :: E)> fn<(e :: E)>(action: (std/core/types/int32) -> (e :: E) (), end: std/core/types/int32, i: std/core/types/int32){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool,(x : std/core/types/int32, y : std/core/types/int32) -> (e :: E) std/core/types/bool>(std/num/int32/(<=))(i, end))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> val _[538,7,538,15] : ()
              = action(i);
            val i@0@10012[1,0,1,0] : std/core/types/int32
              = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32) -> std/core/types/int32,(x : std/core/types/int32) -> (e :: E) std/core/types/int32>((std/core/undiv/pretend-decreasing<std/core/types/int32>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i@1: std/core/types/int32){
                (std/num/int32/(+)(i@1, (std/num/int32/int32(1))));
              }))(i)));
        std/num/int32/#range/@lift-for32@2276<(e :: E)>(action, end, i@0@10012);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/Unit;
    });
  };
recursive specialize "___*" borrow "___^" fip fun range/fold-int32 // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(start: std/core/types/int32, end: std/core/types/int32, init: a, f: (std/core/types/int32, a) -> (e :: E) a){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool,(x : std/core/types/int32, y : std/core/types/int32) -> (e :: E) std/core/types/bool>(std/num/int32/(>))(start, end))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> init;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> val x[513,9,513,9] : a
                  = f(start, init);
        std/num/int32/#range/fold-int32<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32) -> std/core/types/int32,(x : std/core/types/int32) -> (e :: E) std/core/types/int32>((std/core/undiv/pretend-decreasing<std/core/types/int32>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i: std/core/types/int32){
            (std/num/int32/(+)(i, (std/num/int32/int32(1))));
          }))(start)))), end, x, f);
    });
  };
recursive specialize "___*"  fun range/fold-while-int32 // inline size: 12
  = forall<a,(e :: E)> fn<(e :: E)>(start: std/core/types/int32, end: std/core/types/int32, init: a, f: (std/core/types/int32, a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/bool,(x : std/core/types/int32, y : std/core/types/int32) -> (e :: E) std/core/types/bool>(std/num/int32/(>))(start, end))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> init;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> (match ((f(start, init))) {
          ((std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@1: ((std/core/types/maybe :: V -> V)<a>))
             -> std/num/int32/#range/fold-while-int32<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int32) -> std/core/types/int32,(x : std/core/types/int32) -> (e :: E) std/core/types/int32>((std/core/undiv/pretend-decreasing<std/core/types/int32>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int32) -> std/core/types/int32,(i : std/core/types/int32) -> (e :: E) std/core/types/int32>((fn(i: std/core/types/int32){
                (std/num/int32/(+)(i, (std/num/int32/int32(1))));
              }))(start)))), end, x, f);
          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat@2: ((std/core/types/maybe :: V -> V)<a>))
             -> init;
        });
    });
  };
specialize "__*"  fun range/for-while32 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start: std/core/types/int32, end: std/core/types/int32, action: (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/num/int32/#range/@lift-for-while32@2275<a,(e :: E)>(action, end, start);
  };
specialize "__*"  fun range/for32 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start: std/core/types/int32, end: std/core/types/int32, action: (std/core/types/int32) -> (e :: E) ()){
    std/num/int32/#range/@lift-for32@2276<(e :: E)>(action, end, start);
  };
fip fun (^) // inline size: 1
  = fn(x: std/core/types/int32, y: std/core/types/int32){
    std/num/int32/xor(x, y);
  };
fip fun cmp // inline size: 4
  = fn(x: std/core/types/int32, y: std/core/types/int32){
    match ((std/num/int32/(<)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> (match ((std/num/int32/(>)(x, y))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Gt;
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fip fun max // inline size: 2
  = fn(i: std/core/types/int32, j: std/core/types/int32){
    match ((std/num/int32/(>=)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> i;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> j;
    };
  };
fip fun min // inline size: 2
  = fn(i: std/core/types/int32, j: std/core/types/int32){
    match ((std/num/int32/(<=)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> i;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> j;
    };
  };
fip fun sign // inline size: 4
  = fn(i: std/core/types/int32){
    match ((std/num/int32/is-pos(i))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Gt;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> (match ((std/num/int32/is-neg(i))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Lt;
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fip fun bool/int32 // inline size: 1
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/num/int32/one;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/num/int32/zero;
    };
  };
fip fun negate // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(-)((std/num/int32/int32(0)), i);
  };
fip fun bool // inline size: 1
  = fn(i: std/core/types/int32){
    std/num/int32/(!=)(i, std/num/int32/zero);
  };
fip fun dec // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(-)(i, (std/num/int32/int32(1)));
  };
fip fun inc // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(+)(i, (std/num/int32/int32(1)));
  };
 fun range/for-while32 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start: std/core/types/int32, end: std/core/types/int32, action: (std/core/types/int32) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/num/int32/#range/@lift-for-while32@2275<a,(e :: E)>(action, end, start);
  };
 fun range/for32 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start: std/core/types/int32, end: std/core/types/int32, action: (std/core/types/int32) -> (e :: E) ()){
    std/num/int32/#range/@lift-for32@2276<(e :: E)>(action, end, start);
  };
 fun hi // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/sar32(i, (std/num/int32/int32(16)));
  };
inline fip fun i32 // inline size: 1
  = fn(i: std/core/types/int){
    std/num/int32/int32(i);
  };
fip fun is-even // inline size: 4
  = fn(i: std/core/types/int32){
    std/num/int32/(==)((std/num/int32/and(i, (std/num/int32/int32(1)))), (std/num/int32/int32(0)));
  };
fip fun is-odd // inline size: 4
  = fn(i: std/core/types/int32){
    std/num/int32/(==)((std/num/int32/and(i, (std/num/int32/int32(1)))), (std/num/int32/int32(1)));
  };
 fun lo // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/and(i, (std/num/int32/int32(65535)));
  };
fip fun rotl // inline size: 2
  = fn(i: std/core/types/int32, shift: std/core/types/int){
    std/num/int32/rotl32(i, (std/num/int32/int32(shift)));
  };
fip fun rotr // inline size: 2
  = fn(i: std/core/types/int32, shift: std/core/types/int){
    std/num/int32/rotr32(i, (std/num/int32/int32(shift)));
  };
fip fun sar // inline size: 2
  = fn(i: std/core/types/int32, shift: std/core/types/int){
    std/num/int32/sar32(i, (std/num/int32/int32(shift)));
  };
fip fun shl // inline size: 2
  = fn(i: std/core/types/int32, shift: std/core/types/int){
    std/num/int32/shl32(i, (std/num/int32/int32(shift)));
  };
 fun hilo/int // inline size: 4
  = fn(@pat-x405_19: (std/core/types/int32, std/core/types/int32)){
    match (@pat-x405_19) {
      ((@skip std/core/types/Tuple2((hi@0: std/core/types/int32) : std/core/types/int32, (lo@0: std/core/types/int32) : std/core/types/int32) : (std/core/types/int32, std/core/types/int32) ) as @pat: (std/core/types/int32, std/core/types/int32))
         -> val x@10019[1,0,1,0] : std/core/types/int
              = std/core/int/(*)((std/num/int32/int(hi@0)), 4294967296);
            val y@10020[1,0,1,0] : std/core/types/int
              = std/num/int32/uint(lo@0);
        std/core/int/int-add(x@10019, y@10020);
    };
  };
 fun hilo/uint // inline size: 4
  = fn(@pat-x410_20: (std/core/types/int32, std/core/types/int32)){
    match (@pat-x410_20) {
      ((@skip std/core/types/Tuple2((hi@0: std/core/types/int32) : std/core/types/int32, (lo@0: std/core/types/int32) : std/core/types/int32) : (std/core/types/int32, std/core/types/int32) ) as @pat: (std/core/types/int32, std/core/types/int32))
         -> val x@10021[1,0,1,0] : std/core/types/int
              = std/core/int/(*)((std/num/int32/uint(hi@0)), 4294967296);
            val y@10022[1,0,1,0] : std/core/types/int
              = std/num/int32/uint(lo@0);
        std/core/int/int-add(x@10021, y@10022);
    };
  };
 fun show // inline size: 2
  = fn(i: std/core/types/int32){
    std/core/int/show((std/num/int32/int(i)));
  };
fip fun shr // inline size: 2
  = fn(i: std/core/types/int32, shift: std/core/types/int){
    std/num/int32/shr32(i, (std/num/int32/int32(shift)));
  };
borrow "^" fip fun sum32 // inline size: 2
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int32>){
    std/num/int32/sumacc32(xs, (std/num/int32/int32(0)));
  };
fip fun (~) // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(-)((std/num/int32/int32(0)), i);
  };