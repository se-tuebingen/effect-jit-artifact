module interface main
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/os/env = std/os/env = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// ctl done
// ```
recursive effect type abort[5,1,5,12] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-abort[5,1,5,12](@cfc: std/core/types/int, @ctl-done: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,b,(abort :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,b,(abort :: (E, V) -> V),(e :: E),a>) -> (abort :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:abort` type.
 fun abort/@cfc[5,1,5,12] : forall<(e :: E),a> (^ abort : (abort :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-done` constructor field of the `:abort` type.
 fun abort/@ctl-done[6,7,6,22] : forall<(e :: E),a,b> (^ abort : (abort :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,b,(abort :: (E, V) -> V),(e :: E),a>;
// runtime tag for the effect `:abort`
val @tag-abort[5,1,5,12] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(abort :: (E, V) -> V)>;
// handler for the effect `:abort`
 fun @handle-abort[5,8,5,12] : forall<a,(e :: E),b> (hnd : (abort :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `done` operation out of effect `:abort`
 fun @select-done[6,7,6,22] : forall<a,(e :: E),b> (^ hnd : (abort :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,a,(abort :: (E, V) -> V),(e :: E),b>;
// Call the `ctl done` operation of the effect `:abort`
 fun done[6,7,6,10] : forall<a> (i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>> a;
 fun enumerate[13,5,13,13] : (i : std/core/types/int) -> <(std/core/types/div :: X)> (std/core/types/list :: V -> V)<std/core/types/int>;
 fun product[8,5,8,11] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>> std/core/types/int;
 fun run-product[18,5,18,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>) -> std/core/types/int;
// lifted local: run, loop
 fun @lift-run@586[1,0,1,0] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>, i : std/core/types/int, a : std/core/types/int) -> <(std/core/types/div :: X)> std/core/types/int;
 fun run[22,5,22,7] : (n : std/core/types/int) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun main[30,9,30,12] : () -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/ndet :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun abort/@cfc // inline size: 0
  = forall<(e :: E),a> fn(abort: (abort :: (E, V) -> V)<(e :: E),a>){
    (match (abort) {
      ((@skip main/@Hnd-abort((@x: std/core/types/int) : std/core/types/int, (@pat@0: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,b,(abort :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,b,(abort :: (E, V) -> V),(e :: E),a>)) : (abort :: (E, V) -> V)<(e :: E),a> ) as @pat: ((abort :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun abort/@ctl-done // inline size: 0
  = forall<(e :: E),a,b> fn(abort: (abort :: (E, V) -> V)<(e :: E),a>){
    (match (abort) {
      ((@skip main/@Hnd-abort((@pat@0: std/core/types/int) : std/core/types/int, (@x: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,c,(abort :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,c,(abort :: (E, V) -> V),(e :: E),a>)) : (abort :: (E, V) -> V)<(e :: E),a> ) as @pat: ((abort :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
inline borrow "^"  fun @select-done // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (abort :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip main/@Hnd-abort((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-done: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,c,(abort :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,c,(abort :: (E, V) -> V),(e :: E),b>)) : (abort :: (E, V) -> V)<(e :: E),b> ) as @pat: ((abort :: (E, V) -> V)<(e :: E),b>))
         -> @ctl-done<a>;
    });
  };
inline  fun done // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>>>(i: std/core/types/int){
    std/core/hnd/@perform1<std/core/types/int,a,(abort :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(abort :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(abort :: (E, V) -> V)>>((std/core/hnd/@evv-at<(abort :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> main/@select-done<a,(e :: E),b>), i);
  };
 fun run-product // inline size: 4
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>){
    main/@handle-abort<std/core/types/int,(std/core/types/total :: E),std/core/types/int>((main/@Hnd-abort<(std/core/types/total :: E),std/core/types/int>(3, (forall<a> std/core/hnd/clause-control1<std/core/types/int,a,(std/core/types/total :: E),(abort :: (E, V) -> V),std/core/types/int>((fn(r: std/core/types/int, resume: (a) -> std/core/types/int){
          r;
        }))))), (fn(@x: std/core/types/int){
        @x;
      }), (fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(abort :: (E, V) -> V)>>>(){
        (main/product(xs));
      }));
  };
 fun run // inline size: 2
  = fn<<(std/core/types/div :: X)>>(n: std/core/types/int){
    val xs[23,7,23,8] : (std/core/types/list :: V -> V)<std/core/types/int>
          = main/enumerate(1000);
    main/@lift-run@586(xs, n, 0);
  };