module interface main
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/os/env = std/os/env = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
;

// Operations:
// ```koka
// fun emit
// ```
recursive effect type emit[10,1,10,11] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-emit[10,1,10,11](@cfc: std/core/types/int, @fun-emit: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) -> (emit :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// fun read
// ```
recursive effect type read[7,1,7,11] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-read[7,1,7,11](@cfc: std/core/types/int, @fun-read: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(chr == 1 std/core/types/int),(read :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(chr == 1 std/core/types/int),(read :: (E, V) -> V),(e :: E),a>) -> (read :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// ctl stop
// ```
recursive effect type stop[13,1,13,11] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-stop[13,1,13,11](@cfc: std/core/types/int, @ctl-stop: forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(stop :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(stop :: (E, V) -> V),(e :: E),a>) -> (stop :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:emit` type.
 fun emit/@cfc[10,1,10,11] : forall<(e :: E),a> (^ emit : (emit :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-emit` constructor field of the `:emit` type.
 fun emit/@fun-emit[11,7,11,23] : forall<(e :: E),a> (^ emit : (emit :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:read` type.
 fun read/@cfc[7,1,7,11] : forall<(e :: E),a> (^ read : (read :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-read` constructor field of the `:read` type.
 fun read/@fun-read[8,7,8,17] : forall<(e :: E),a> (^ read : (read :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:stop` type.
 fun stop/@cfc[13,1,13,11] : forall<(e :: E),a> (^ stop : (stop :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-stop` constructor field of the `:stop` type.
 fun stop/@ctl-stop[14,7,14,15] : forall<(e :: E),a,b> (^ stop : (stop :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(stop :: (E, V) -> V),(e :: E),a>;
// runtime tag for the effect `:emit`
val @tag-emit[10,1,10,11] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(emit :: (E, V) -> V)>;
// handler for the effect `:emit`
 fun @handle-emit[10,8,10,11] : forall<a,(e :: E),b> (hnd : (emit :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// runtime tag for the effect `:read`
val @tag-read[7,1,7,11] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(read :: (E, V) -> V)>;
// handler for the effect `:read`
 fun @handle-read[7,8,7,11] : forall<a,(e :: E),b> (hnd : (read :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// runtime tag for the effect `:stop`
val @tag-stop[13,1,13,11] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(stop :: (E, V) -> V)>;
// handler for the effect `:stop`
 fun @handle-stop[13,8,13,11] : forall<a,(e :: E),b> (hnd : (stop :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `emit` operation out of effect `:emit`
 fun @select-emit[11,7,11,23] : forall<(e :: E),a> (^ hnd : (emit :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>;
// select `read` operation out of effect `:read`
 fun @select-read[8,7,8,17] : forall<(e :: E),a> (^ hnd : (read :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>;
// select `stop` operation out of effect `:stop`
 fun @select-stop[14,7,14,15] : forall<a,(e :: E),b> (^ hnd : (stop :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(stop :: (E, V) -> V),(e :: E),b>;
 fun dollar[20,5,20,10] : () -> chr;
 fun newline[16,5,16,11] : () -> chr;
 fun is-dollar[22,5,22,13] : (c : chr) -> std/core/types/bool;
 fun is-newline[18,5,18,14] : (c : chr) -> std/core/types/bool;
// Call the `ctl stop` operation of the effect `:stop`
 fun stop[14,7,14,10] : forall<a> () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>> a;
 fun catch[44,5,44,9] : forall<(e :: E)> (action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>|(e :: E)> ()) -> (e :: E) ();
// Call the `fun emit` operation of the effect `:emit`
 fun emit[11,7,11,10] : (e : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>> ();
// Call the `fun read` operation of the effect `:read`
 fun read[8,7,8,10] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>> chr;
 fun feed[49,5,49,8] : forall<(e :: E)> (n : std/core/types/int, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>|(e :: E)> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>|(e :: E)> ();
 fun parse[25,5,25,9] : forall<a> (a : std/core/types/int) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>> a;
 fun sum[36,5,36,7] : forall<(e :: E)> (action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>|(e :: E)> ()) -> (e :: E) std/core/types/int;
 fun run[65,5,65,7] : (n : std/core/types/int) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun main[68,9,68,12] : () -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/ndet :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun emit/@cfc // inline size: 0
  = forall<(e :: E),a> fn(emit@0: (emit :: (E, V) -> V)<(e :: E),a>){
    (match (emit@0) {
      ((@skip main/@Hnd-emit((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) : (emit :: (E, V) -> V)<(e :: E),a> ) as @pat: ((emit :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun emit/@fun-emit // inline size: 0
  = forall<(e :: E),a> fn(emit@0: (emit :: (E, V) -> V)<(e :: E),a>){
    (match (emit@0) {
      ((@skip main/@Hnd-emit((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) : (emit :: (E, V) -> V)<(e :: E),a> ) as @pat: ((emit :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun read/@cfc // inline size: 0
  = forall<(e :: E),a> fn(read@0: (read :: (E, V) -> V)<(e :: E),a>){
    (match (read@0) {
      ((@skip main/@Hnd-read((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>) : (read :: (E, V) -> V)<(e :: E),a> ) as @pat: ((read :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun read/@fun-read // inline size: 0
  = forall<(e :: E),a> fn(read@0: (read :: (E, V) -> V)<(e :: E),a>){
    (match (read@0) {
      ((@skip main/@Hnd-read((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>) : (read :: (E, V) -> V)<(e :: E),a> ) as @pat: ((read :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun stop/@cfc // inline size: 0
  = forall<(e :: E),a> fn(stop@0: (stop :: (E, V) -> V)<(e :: E),a>){
    (match (stop@0) {
      ((@skip main/@Hnd-stop((@x: std/core/types/int) : std/core/types/int, (@pat@0: (forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(stop :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(stop :: (E, V) -> V),(e :: E),a>)) : (stop :: (E, V) -> V)<(e :: E),a> ) as @pat: ((stop :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun stop/@ctl-stop // inline size: 0
  = forall<(e :: E),a,b> fn(stop@0: (stop :: (E, V) -> V)<(e :: E),a>){
    (match (stop@0) {
      ((@skip main/@Hnd-stop((@pat@0: std/core/types/int) : std/core/types/int, (@x: (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(stop :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(stop :: (E, V) -> V),(e :: E),a>)) : (stop :: (E, V) -> V)<(e :: E),a> ) as @pat: ((stop :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
inline borrow "^"  fun @select-emit // inline size: 0
  = forall<(e :: E),a> fn(hnd: (emit :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-emit((@pat@0: std/core/types/int) : std/core/types/int, (@fun-emit: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/int,(),(emit :: (E, V) -> V),(e :: E),a>) : (emit :: (E, V) -> V)<(e :: E),a> ) as @pat: ((emit :: (E, V) -> V)<(e :: E),a>))
         -> @fun-emit;
    });
  };
inline borrow "^"  fun @select-read // inline size: 0
  = forall<(e :: E),a> fn(hnd: (read :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-read((@pat@0: std/core/types/int) : std/core/types/int, (@fun-read: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<chr,(read :: (E, V) -> V),(e :: E),a>) : (read :: (E, V) -> V)<(e :: E),a> ) as @pat: ((read :: (E, V) -> V)<(e :: E),a>))
         -> @fun-read;
    });
  };
inline borrow "^"  fun @select-stop // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (stop :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip main/@Hnd-stop((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-stop: (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(stop :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(stop :: (E, V) -> V),(e :: E),b>)) : (stop :: (E, V) -> V)<(e :: E),b> ) as @pat: ((stop :: (E, V) -> V)<(e :: E),b>))
         -> @ctl-stop<a>;
    });
  };
inline  fun dollar // inline size: 0
  = fn(){
    36;
  };
inline  fun newline // inline size: 0
  = fn(){
    10;
  };
 fun is-dollar // inline size: 1
  = fn(c: chr){
    std/core/int/(==)(c, 36);
  };
 fun is-newline // inline size: 1
  = fn(c: chr){
    std/core/int/(==)(c, 10);
  };
inline  fun stop // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>>,(stop :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(stop :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(stop :: (E, V) -> V)>>((std/core/hnd/@evv-at<(stop :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> main/@select-stop<a,(e :: E),b>));
  };
 fun catch // inline size: 4
  = forall<(e :: E)> fn<(e :: E)>(action: () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(stop :: (E, V) -> V)>|(e :: E)> ()){
    main/@handle-stop<(),(e :: E),()>((main/@Hnd-stop<(e :: E),()>(3, (forall<a> std/core/types/@open<(std/core/types/total :: E),(e :: E),(op : ((a) -> (e :: E) ()) -> (e :: E) ()) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(stop :: (E, V) -> V),(e :: E),()>,(op : ((a) -> (e :: E) ()) -> (e :: E) ()) -> (e :: E) (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(stop :: (E, V) -> V),(e :: E),()>>((std/core/hnd/clause-control0<a,(e :: E),(stop :: (E, V) -> V),()>))((fn<(e :: E)>(resume: (a) -> (e :: E) ()){
          std/core/types/Unit;
        }))))), (fn<(e :: E)>(@x: ()){
        @x;
      }), action);
  };
inline  fun emit // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>>>(e: std/core/types/int){
    std/core/hnd/@perform1<std/core/types/int,(),(emit :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(emit :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(emit :: (E, V) -> V)>>((std/core/hnd/@evv-at<(emit :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(emit :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-emit, e);
  };
inline  fun read // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<chr,<(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>>,(read :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(read :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(read :: (E, V) -> V)>>((std/core/hnd/@evv-at<(read :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(read :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-read);
  };